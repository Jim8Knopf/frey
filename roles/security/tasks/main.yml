---
# ==============================================================================
# SECURITY ROLE - MAIN TASKS
# ==============================================================================
# Configures firewall (UFW), IP forwarding, NAT, and security services for
# Raspberry Pi 5 with dual-mode WiFi Access Point functionality.
#
# KEY FEATURES:
# - UFW-only firewall (eliminates iptables complexity and duplicates)
# - Auto-detect trusted networks (home, public WiFi) for dynamic access control
# - Dual-mode WiFi AP (works on home network OR public WiFi)
# - NAT configuration for internet passthrough to WiFi clients
# - Rate limiting to prevent brute force and DDoS attacks
# ==============================================================================

# ------------------------------------------------------------------------------
# 1. PACKAGE INSTALLATION
# ------------------------------------------------------------------------------

- name: Update apt cache
  ansible.builtin.apt:
    update_cache: yes
    cache_valid_time: 3600
  tags: packages

- name: Purge any partial UFW installation
  ansible.builtin.apt:
    name: ufw
    state: absent
    purge: yes
  when: enable_ufw | default(true)
  tags: packages

- name: Install security packages
  ansible.builtin.apt:
    name:
      - ufw                         # Uncomplicated Firewall (front-end to iptables, manages persistence)
      - fail2ban                    # Intrusion prevention (bans IPs after failed attempts)
      - unattended-upgrades         # Automatic security updates
      - logwatch                    # Log analysis and reporting
    state: present
  register: package_install
  tags: packages

# Wait for package locks to clear (prevents dpkg errors)
- name: Wait for dpkg lock
  ansible.builtin.shell: while fuser /var/lib/dpkg/lock >/dev/null 2>&1; do sleep 1; done
  when: package_install.changed
  changed_when: false
  tags: packages

- name: Wait for apt lock
  ansible.builtin.shell: while fuser /var/lib/apt/lists/lock >/dev/null 2>&1; do sleep 1; done
  when: package_install.changed
  changed_when: false
  tags: packages

- name: Wait for package installation to complete
  ansible.builtin.pause:
    seconds: 5
  when: package_install.changed
  tags: packages

# ------------------------------------------------------------------------------
# 2. DETECT UPSTREAM NETWORK (Auto-trust current network)
# ------------------------------------------------------------------------------
# Automatically detect which network the Pi is currently connected to and add
# it to trusted networks. This enables the Pi to work on home network, friend's
# house, public WiFi, etc. without manual firewall configuration.
#
# SECURITY NOTE: This trusts the current upstream network. On public WiFi,
# only the WiFi AP's local network (10.20.0.x) will have this trust, not
# other devices on the public WiFi.

- name: Detect upstream network interface
  ansible.builtin.shell: |
    # Find the interface with default route (upstream internet connection)
    ip route | grep default | awk '{print $5}' | head -1
  register: upstream_interface_result
  changed_when: false
  failed_when: false
  tags: network_detection

- name: Detect upstream network subnet
  ansible.builtin.shell: |
    # Get the IP and netmask of upstream interface, calculate subnet
    IFACE="{{ upstream_interface_result.stdout | trim }}"
    if [ -n "$IFACE" ]; then
      ip -o -f inet addr show "$IFACE" | awk '{print $4}'
    fi
  register: upstream_subnet_result
  changed_when: false
  failed_when: false
  when: upstream_interface_result.stdout | length > 0
  tags: network_detection

- name: Set upstream network as trusted
  ansible.builtin.set_fact:
    detected_upstream_network: "{{ upstream_subnet_result.stdout | trim }}"
  when:
    - upstream_subnet_result.stdout is defined
    - upstream_subnet_result.stdout | length > 0
  tags: network_detection

- name: Display detected upstream network
  ansible.builtin.debug:
    msg: "Detected upstream network: {{ detected_upstream_network | default('none - using defaults') }}"
  tags: network_detection

# ------------------------------------------------------------------------------
# 3. AUTO-DISCOVER DOCKER SERVICES (Dynamic Firewall Configuration)
# ------------------------------------------------------------------------------
# Query Docker for running containers with Traefik labels to automatically
# build firewall rules. This eliminates manual configuration when adding services.
#
# BENEFITS:
# - New services automatically get firewall protection
# - No manual updates to protected_ports list needed
# - Reduces human error and forgotten configurations
# - Adapts to actual running services, not hardcoded assumptions

- name: Discover Traefik-enabled Docker containers
  ansible.builtin.shell: |
    docker ps --filter "label=traefik.enable=true" --format '{{ '{{' }}.Names{{ '}}' }}' 2>/dev/null || true
  register: docker_traefik_containers
  changed_when: false
  failed_when: false
  tags:
    - firewall
    - service_discovery

- name: Extract service ports from Docker container labels
  ansible.builtin.shell: |
    CONTAINER="{{ item }}"
    # Get the Traefik loadbalancer port label
    PORT=$(docker inspect "$CONTAINER" --format '{{ '{{' }}index .Config.Labels "traefik.http.services.'$CONTAINER'.loadbalancer.server.port"{{ '}}' }}' 2>/dev/null || echo "")
    if [ -n "$PORT" ]; then
      echo "$CONTAINER:$PORT"
    fi
  loop: "{{ docker_traefik_containers.stdout_lines }}"
  register: docker_service_ports
  changed_when: false
  failed_when: false
  when: docker_traefik_containers.stdout_lines | length > 0
  tags:
    - firewall
    - service_discovery

- name: Build discovered services list
  ansible.builtin.set_fact:
    discovered_services: "{{ discovered_services | default([]) + [{'port': item.stdout.split(':')[1] | int, 'service': item.stdout.split(':')[0], 'description': item.stdout.split(':')[0] + ' (auto-discovered)'}] }}"
  loop: "{{ docker_service_ports.results }}"
  when:
    - docker_service_ports.results is defined
    - item.stdout is defined
    - item.stdout | length > 0
    - "':' in item.stdout"
  tags:
    - firewall
    - service_discovery

- name: Merge static and discovered protected ports
  ansible.builtin.set_fact:
    all_protected_ports: "{{ (network_security.protected_ports | default([])) + (discovered_services | default([])) }}"
  tags:
    - firewall
    - service_discovery

- name: Display discovered services
  ansible.builtin.debug:
    msg: "Auto-discovered {{ discovered_services | default([]) | length }} services from Docker: {{ discovered_services | default([]) | map(attribute='service') | list | join(', ') }}"
  tags:
    - firewall
    - service_discovery

# ------------------------------------------------------------------------------
# 4. SYSCTL CONFIGURATION (IP Forwarding & Connection Tracking)
# ------------------------------------------------------------------------------
# Configure kernel parameters for:
# - IP forwarding (required for NAT and WiFi AP internet passthrough)
# - Connection tracking (optimized for many WiFi clients)
# - Security hardening (prevent IP spoofing, ICMP redirects, etc.)

- name: Ensure nf_conntrack module is loaded for connection tracking
  community.general.modprobe:
    name: nf_conntrack
    state: present
  when: network.wifi is defined
  tags:
    - sysctl
    - wifi_ap

- name: Configure sysctl for IP forwarding and connection tracking
  ansible.builtin.sysctl:
    name: "{{ item.key }}"
    value: "{{ item.value }}"
    sysctl_file: /etc/sysctl.d/99-frey-security.conf
    reload: yes
  loop:
    # IP FORWARDING - Enable routing between interfaces
    - { key: 'net.ipv4.ip_forward', value: '1' }
    - { key: 'net.ipv4.conf.all.forwarding', value: '1' }
    - { key: 'net.ipv4.conf.default.forwarding', value: '1' }

    # CONNECTION TRACKING - Optimize for NAT with many WiFi clients
    - { key: 'net.netfilter.nf_conntrack_max', value: '65536' }
    - { key: 'net.netfilter.nf_conntrack_tcp_timeout_established', value: '7200' }
    - { key: 'net.netfilter.nf_conntrack_udp_timeout', value: '120' }

    # SECURITY HARDENING
    - { key: 'net.ipv4.conf.all.rp_filter', value: '1' }  # Reverse path filtering (anti-spoofing)
    - { key: 'net.ipv4.conf.default.rp_filter', value: '1' }
    - { key: 'net.ipv4.conf.all.accept_redirects', value: '0' }  # Ignore ICMP redirects
    - { key: 'net.ipv4.conf.default.accept_redirects', value: '0' }
    - { key: 'net.ipv4.conf.all.send_redirects', value: '0' }  # Don't send ICMP redirects
    - { key: 'net.ipv4.conf.default.send_redirects', value: '0' }
    - { key: 'net.ipv4.icmp_echo_ignore_broadcasts', value: '1' }  # Ignore ping broadcasts
    - { key: 'net.ipv4.icmp_ignore_bogus_error_responses', value: '1' }
  when: network.wifi is defined
  tags:
    - sysctl
    - wifi_ap

# ------------------------------------------------------------------------------
# 4. UFW FIREWALL CONFIGURATION
# ------------------------------------------------------------------------------
# All firewall rules use UFW (Uncomplicated Firewall) for simplicity and
# maintainability. UFW is a front-end to iptables that makes rule management
# much easier while providing the same security.
#
# RULE ORDER MATTERS:
# 1. Reset UFW to clean state
# 2. Set default policies (deny incoming, allow outgoing, allow routing)
# 3. Public services (accessible from anywhere)
# 4. WiFi AP services (DNS, DHCP)
# 5. Trusted network access (home network, auto-detected networks)
# 6. WiFi AP restrictions (block direct container access)
# 7. Rate limiting (prevent brute force and DDoS)

- name: Reset UFW to default state #? is this really necessary
  ansible.builtin.command: ufw --force reset
  changed_when: true
  when: enable_ufw | default(true)
  tags:
    - firewall
    - ufw

- name: Set UFW default policies
  ansible.builtin.command: "{{ item }}"
  loop:
    - ufw default deny incoming      # Block all incoming by default (whitelist approach)
    - ufw default allow outgoing     # Allow all outgoing (Pi can reach internet)
    - ufw default allow routed       # Allow routing/forwarding (required for NAT)
  changed_when: true
  when: enable_ufw | default(true)
  tags:
    - firewall
    - ufw

# PUBLIC SERVICES - Accessible from anywhere
# These are Traefik HTTP/HTTPS ports that route to internal services
- name: Allow public services (HTTP/HTTPS through Traefik)
  community.general.ufw:
    rule: allow
    port: "{{ item.port }}"
    proto: "{{ item.proto }}"
    comment: "PUBLIC: {{ item.description }}"
  loop: "{{ network_security.public_ports }}"
  when: enable_ufw | default(true)
  tags:
    - firewall
    - ufw

# WIFI AP SERVICES - DNS and DHCP for WiFi clients
# These must be accessible from WiFi AP clients to get IP and resolve names
- name: Allow DNS (TCP) for WiFi AP clients
  community.general.ufw:
    rule: allow
    port: '53'
    proto: tcp
    comment: "WIFI_AP: DNS over TCP for WiFi clients"
  when:
    - enable_ufw | default(true)
    - network.wifi is defined
  tags:
    - firewall
    - ufw
    - wifi_ap

- name: Allow DNS (UDP) for WiFi AP clients
  community.general.ufw:
    rule: allow
    port: '53'
    proto: udp
    comment: "WIFI_AP: DNS over UDP for WiFi clients"
  when:
    - enable_ufw | default(true)
    - network.wifi is defined
  tags:
    - firewall
    - ufw
    - wifi_ap

- name: Allow DHCP for WiFi AP clients
  community.general.ufw:
    rule: allow
    port: '67'
    proto: udp
    comment: "WIFI_AP: DHCP server for IP assignment"
  when:
    - enable_ufw | default(true)
    - network.wifi is defined
  tags:
    - firewall
    - ufw
    - wifi_ap

# TRUSTED NETWORKS - Full access to all services (including container ports)
# Home network and auto-detected networks can access services directly
- name: Allow all traffic from trusted networks (configured)
  community.general.ufw:
    rule: allow
    from_ip: "{{ item }}"
    comment: "TRUSTED: Full access from {{ item }}"
  loop: "{{ network_security.trusted_networks }}"
  when: enable_ufw | default(true)
  tags:
    - firewall
    - ufw
    - trusted_networks

- name: Allow all traffic from auto-detected upstream network
  community.general.ufw:
    rule: allow
    from_ip: "{{ detected_upstream_network }}"
    comment: "TRUSTED: Auto-detected upstream network"
  when:
    - enable_ufw | default(true)
    - detected_upstream_network is defined
    - detected_upstream_network | length > 0
  tags:
    - firewall
    - ufw
    - trusted_networks

# WIFI AP RESTRICTIONS - Block direct container port access
# Force WiFi clients to use Traefik (service.frey) instead of direct IPs
# This ensures authentication and rate limiting are enforced
# Uses combined static + auto-discovered services list
- name: Block direct container port access from WiFi AP clients
  community.general.ufw:
    rule: deny
    port: "{{ item.port }}"
    proto: tcp
    from_ip: "{{ network_security.wifi_ap_network }}"
    comment: "WIFI_BLOCK: {{ item.description }} (use {{ item.service }}.frey instead)"
  loop: "{{ all_protected_ports | default(network_security.protected_ports) }}"
  when:
    - enable_ufw | default(true)
    - network.wifi is defined
    - all_protected_ports is defined or network_security.protected_ports is defined
  tags:
    - firewall
    - ufw
    - wifi_ap

# RATE LIMITING - Prevent brute force and DDoS attacks
# Limits connection attempts to prevent password guessing and basic DDoS
- name: Enable rate limiting on SSH (max 6 connections per 30 seconds)
  ansible.builtin.command: ufw limit ssh
  changed_when: true
  when: enable_ufw | default(true)
  tags:
    - firewall
    - ufw
    - rate_limit

- name: Enable UFW firewall
  ansible.builtin.command: ufw --force enable
  changed_when: true
  when: enable_ufw | default(true)
  tags:
    - firewall
    - ufw
    
- name: Allow Docker traffic through UFW
  ufw:
    rule: allow
    port: "6881"
    proto: "{{ item }}"
    comment: "DOCKER: qBittorrent torrent traffic"
  loop:
    - tcp
    - udp

# ------------------------------------------------------------------------------
# 5. NAT CONFIGURATION (Internet Passthrough for WiFi AP)
# ------------------------------------------------------------------------------
# Configure NAT/MASQUERADE so WiFi AP clients can access internet through
# the Pi's upstream connection (home network or public WiFi).
#
# This uses raw iptables because UFW doesn't support NAT table directly.
# These rules are in addition to UFW rules above.

- name: Configure NAT for WiFi AP internet passthrough
  when: network.wifi is defined
  tags:
    - firewall
    - wifi_ap
    - nat
  block:
    - name: Get upstream interface for NAT
      ansible.builtin.shell: |
        # Use detected upstream interface from earlier
        echo "{{ upstream_interface_result.stdout | trim }}"
      register: nat_upstream_interface
      changed_when: false

    - name: Configure MASQUERADE for WiFi AP clients
      ansible.builtin.iptables:
        table: nat
        chain: POSTROUTING
        source: "{{ network.wifi.network }}"
        out_interface: "{{ nat_upstream_interface.stdout | trim }}"
        jump: MASQUERADE
        comment: "NAT: Internet passthrough for WiFi AP clients"

    - name: Allow established/related connections in FORWARD chain
      ansible.builtin.iptables:
        chain: FORWARD
        ctstate: ESTABLISHED,RELATED
        jump: ACCEPT
        comment: "NAT: Allow return traffic for established connections"

    - name: Allow forwarding from WiFi AP interface
      ansible.builtin.iptables:
        chain: FORWARD
        in_interface: "{{ network.wifi.interface }}"
        jump: ACCEPT
        comment: "NAT: Allow forwarding from WiFi AP to internet"

    - name: Create directory for UFW NAT rules
      ansible.builtin.file:
        path: /etc/ufw
        state: directory
        mode: '0755'

    - name: Configure UFW to load NAT rules on startup
      ansible.builtin.blockinfile:
        path: /etc/ufw/before.rules
        marker: "# {mark} ANSIBLE MANAGED NAT RULES"
        insertbefore: "\\*filter"
        block: |
          # NAT table rules for WiFi AP internet passthrough
          *nat
          :POSTROUTING ACCEPT [0:0]

          # MASQUERADE traffic from WiFi AP clients ({{ network.wifi.network }})
          -A POSTROUTING -s {{ network.wifi.network }} -o {{ upstream_interface_result.stdout | trim }} -j MASQUERADE

          # End NAT table
          COMMIT
        create: no
      notify: reload ufw

# ------------------------------------------------------------------------------
# 6. FAIL2BAN CONFIGURATION
# ------------------------------------------------------------------------------
# Configure fail2ban to automatically ban IPs after failed login attempts

- name: Configure fail2ban
  ansible.builtin.template:
    src: jail.local.j2
    dest: /etc/fail2ban/jail.local
    mode: '0644'
  when: enable_fail2ban | default(true)
  notify: restart fail2ban
  tags:
    - fail2ban

# ------------------------------------------------------------------------------
# 7. AUTOMATIC SECURITY UPDATES
# ------------------------------------------------------------------------------
# Enable unattended-upgrades for automatic security patches

- name: Enable automatic security updates
  ansible.builtin.lineinfile:
    path: /etc/apt/apt.conf.d/50unattended-upgrades
    regexp: '^//.*"{{ ansible_distribution }}:{{ ansible_distribution_release }}-security";'
    line: '        "{{ ansible_distribution }}:{{ ansible_distribution_release }}-security";'
    state: present
  tags:
    - auto_updates
