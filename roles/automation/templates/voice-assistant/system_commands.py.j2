#!/usr/bin/env python3
"""
System Commands Handler - Execute system operations via voice commands.
Handles Docker container control, service status checks, and system information.
"""

import logging
import docker
from typing import Optional, List, Dict
import subprocess

logger = logging.getLogger(__name__)


class SystemCommandHandler:
    """Handles system command execution."""

    def __init__(self, docker_socket: str, frey_domain: str):
        """
        Initialize system command handler.

        Args:
            docker_socket: Path to Docker socket
            frey_domain: Frey domain name
        """
        self.frey_domain = frey_domain

        # Initialize Docker client
        try:
            self.docker_client = docker.DockerClient(base_url=f"unix://{docker_socket}")
            logger.info("Docker client initialized")
        except Exception as e:
            logger.error(f"Failed to initialize Docker client: {e}")
            self.docker_client = None

        # Service name mappings for easier voice commands
        self.service_aliases = {
            # Media services
            'jellyfin': 'jellyfin',
            'jelly fin': 'jellyfin',
            'sonar': 'sonarr',
            'sonarr': 'sonarr',
            'radar': 'radarr',
            'radarr': 'radarr',
            'bazaar': 'bazarr',
            'bazarr': 'bazarr',
            'lidar': 'lidarr',
            'lidarr': 'lidarr',
            'prowler': 'prowlarr',
            'prowlarr': 'prowlarr',
            'qbittorrent': 'qbittorrent',
            'torrent': 'qbittorrent',
            'audiobook shelf': 'audiobookshelf',
            'audiobookshelf': 'audiobookshelf',

            # Infrastructure
            'portainer': 'portainer',
            'traefik': 'traefik',
            'traffic': 'traefik',
            'dockge': 'dockge',
            'authentik': 'authentik',

            # Automation
            'home assistant': 'homeassistant',
            'ollama': 'ollama',
            'n8n': 'n8n',

            # Monitoring
            'grafana': 'grafana',
            'prometheus': 'prometheus',
        }

    def normalize_service_name(self, service_input: str) -> Optional[str]:
        """
        Normalize service name from voice input.

        Args:
            service_input: Raw service name from voice

        Returns:
            Normalized container name or None
        """
        service_lower = service_input.lower().strip()

        # Check aliases
        if service_lower in self.service_aliases:
            return self.service_aliases[service_lower]

        # Check if it matches a container name directly
        if self.docker_client:
            try:
                containers = self.docker_client.containers.list(all=True)
                for container in containers:
                    if service_lower in container.name.lower():
                        return container.name
            except Exception as e:
                logger.error(f"Failed to list containers: {e}")

        return None

    def start_service(self, service_name: str) -> str:
        """
        Start a Docker service.

        Args:
            service_name: Service name to start

        Returns:
            Status message
        """
        if not self.docker_client:
            return "Docker control is not available."

        try:
            # Normalize service name
            container_name = self.normalize_service_name(service_name)

            if not container_name:
                return f"I couldn't find a service called {service_name}."

            # Get container
            container = self.docker_client.containers.get(container_name)

            # Check current status
            if container.status == 'running':
                return f"{container_name} is already running."

            # Start container
            container.start()
            logger.info(f"Started container: {container_name}")
            return f"{container_name} has been started."

        except docker.errors.NotFound:
            return f"Service {service_name} was not found."
        except Exception as e:
            logger.error(f"Failed to start {service_name}: {e}")
            return f"Failed to start {service_name}."

    def stop_service(self, service_name: str) -> str:
        """
        Stop a Docker service.

        Args:
            service_name: Service name to stop

        Returns:
            Status message
        """
        if not self.docker_client:
            return "Docker control is not available."

        # Don't allow stopping critical services
        critical_services = ['voice-assistant', 'ollama', 'piper', 'wyoming-whisper', 'openwakeword']

        try:
            # Normalize service name
            container_name = self.normalize_service_name(service_name)

            if not container_name:
                return f"I couldn't find a service called {service_name}."

            # Check if it's a critical service
            if container_name in critical_services:
                return f"I can't stop {container_name} because it's required for my operation."

            # Get container
            container = self.docker_client.containers.get(container_name)

            # Check current status
            if container.status != 'running':
                return f"{container_name} is not running."

            # Stop container
            container.stop(timeout=10)
            logger.info(f"Stopped container: {container_name}")
            return f"{container_name} has been stopped."

        except docker.errors.NotFound:
            return f"Service {service_name} was not found."
        except Exception as e:
            logger.error(f"Failed to stop {service_name}: {e}")
            return f"Failed to stop {service_name}."

    def get_service_status(self, service_name: Optional[str] = None) -> str:
        """
        Get status of one or all services.

        Args:
            service_name: Specific service name, or None for all services

        Returns:
            Status message
        """
        if not self.docker_client:
            return "Docker control is not available."

        try:
            if service_name and service_name.lower() != 'all':
                # Get specific service status
                container_name = self.normalize_service_name(service_name)

                if not container_name:
                    return f"I couldn't find a service called {service_name}."

                container = self.docker_client.containers.get(container_name)
                status = "running" if container.status == "running" else "stopped"
                return f"{container_name} is {status}."

            else:
                # Get all service statuses
                containers = self.docker_client.containers.list(all=True)
                running = sum(1 for c in containers if c.status == 'running')
                total = len(containers)
                return f"{running} out of {total} services are running."

        except docker.errors.NotFound:
            return f"Service {service_name} was not found."
        except Exception as e:
            logger.error(f"Failed to get status: {e}")
            return "Failed to check service status."

    def get_system_info(self) -> str:
        """
        Get basic system information.

        Returns:
            System info message
        """
        try:
            # Get CPU usage
            cpu_usage = self._get_cpu_usage()

            # Get memory info
            memory_info = self._get_memory_info()

            # Get disk usage
            disk_usage = self._get_disk_usage()

            return f"CPU usage is {cpu_usage}%. Memory usage is {memory_info}. Disk usage is {disk_usage}."

        except Exception as e:
            logger.error(f"Failed to get system info: {e}")
            return "Failed to retrieve system information."

    def _get_cpu_usage(self) -> float:
        """Get CPU usage percentage."""
        try:
            # Use top command to get CPU usage
            result = subprocess.run(
                ["top", "-bn1"],
                capture_output=True,
                text=True,
                timeout=5
            )
            for line in result.stdout.split('\n'):
                if 'Cpu(s)' in line or '%Cpu' in line:
                    # Parse CPU line
                    parts = line.split(',')
                    for part in parts:
                        if 'id' in part:  # idle percentage
                            idle = float(part.split()[0])
                            return round(100 - idle, 1)
        except Exception as e:
            logger.debug(f"CPU usage check failed: {e}")

        return 0.0

    def _get_memory_info(self) -> str:
        """Get memory usage information."""
        try:
            result = subprocess.run(
                ["free", "-h"],
                capture_output=True,
                text=True,
                timeout=5
            )
            lines = result.stdout.split('\n')
            if len(lines) > 1:
                # Parse memory line
                parts = lines[1].split()
                if len(parts) >= 3:
                    used = parts[2]
                    total = parts[1]
                    return f"{used} of {total}"
        except Exception as e:
            logger.debug(f"Memory check failed: {e}")

        return "unknown"

    def _get_disk_usage(self) -> str:
        """Get disk usage information."""
        try:
            result = subprocess.run(
                ["df", "-h", "/opt/frey"],
                capture_output=True,
                text=True,
                timeout=5
            )
            lines = result.stdout.split('\n')
            if len(lines) > 1:
                parts = lines[1].split()
                if len(parts) >= 5:
                    used_pct = parts[4]
                    return used_pct
        except Exception as e:
            logger.debug(f"Disk usage check failed: {e}")

        return "unknown"

    def list_available_services(self) -> List[str]:
        """
        Get list of available service names.

        Returns:
            List of service names
        """
        if not self.docker_client:
            return []

        try:
            containers = self.docker_client.containers.list(all=True)
            return [c.name for c in containers]
        except Exception as e:
            logger.error(f"Failed to list services: {e}")
            return []
