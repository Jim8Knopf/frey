#!/usr/bin/env python3
"""
Wyoming Protocol Clients - Communication with Wyoming services.
Handles STT (Whisper), TTS (Piper), and Wake Word (OpenWakeWord).
"""

import asyncio
import io
import struct
import logging
from typing import Optional

logger = logging.getLogger(__name__)


class WyomingClient:
    """Base Wyoming protocol client."""

    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port

    async def _connect(self):
        """Establish connection to Wyoming service."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.host, self.port),
                timeout=5.0
            )
            return reader, writer
        except Exception as e:
            logger.error(f"Connection to {self.host}:{self.port} failed: {e}")
            raise


class WyomingSTTClient(WyomingClient):
    """Wyoming Speech-to-Text client (Whisper)."""

    async def transcribe(self, audio_data: bytes) -> Optional[str]:
        """
        Transcribe audio to text.

        Args:
            audio_data: WAV audio data

        Returns:
            Transcribed text or None if failed
        """
        try:
            reader, writer = await self._connect()

            # Wyoming protocol for STT
            # Send audio-start event
            writer.write(b'audio-start\n')
            await writer.drain()

            # Send audio data in chunks
            chunk_size = 8192
            for i in range(0, len(audio_data), chunk_size):
                chunk = audio_data[i:i + chunk_size]
                # Send chunk with length prefix
                writer.write(struct.pack('<I', len(chunk)))
                writer.write(chunk)
                await writer.drain()

            # Send audio-stop event
            writer.write(b'audio-stop\n')
            await writer.drain()

            # Read transcription result
            response = await asyncio.wait_for(reader.readline(), timeout=30.0)
            writer.close()
            await writer.wait_closed()

            # Parse response
            text = response.decode('utf-8').strip()
            return text if text else None

        except asyncio.TimeoutError:
            logger.error("STT transcription timed out")
            return None
        except Exception as e:
            logger.error(f"STT transcription failed: {e}", exc_info=True)
            return None


class WyomingTTSClient(WyomingClient):
    """Wyoming Text-to-Speech client (Piper)."""

    def __init__(self, host: str, port: int, voice: str):
        super().__init__(host, port)
        self.voice = voice

    async def synthesize(self, text: str) -> Optional[bytes]:
        """
        Synthesize text to speech.

        Args:
            text: Text to synthesize

        Returns:
            WAV audio data or None if failed
        """
        try:
            reader, writer = await self._connect()

            # Wyoming protocol for TTS
            # Send synthesize command with voice
            command = f'synthesize|voice={self.voice}|text={text}\n'
            writer.write(command.encode('utf-8'))
            await writer.drain()

            # Read audio data length
            length_data = await reader.readexactly(4)
            audio_length = struct.unpack('<I', length_data)[0]

            # Read audio data
            audio_data = await asyncio.wait_for(
                reader.readexactly(audio_length),
                timeout=30.0
            )

            writer.close()
            await writer.wait_closed()

            return audio_data if audio_data else None

        except asyncio.TimeoutError:
            logger.error("TTS synthesis timed out")
            return None
        except Exception as e:
            logger.error(f"TTS synthesis failed: {e}", exc_info=True)
            return None


class WyomingWakeWordClient(WyomingClient):
    """Wyoming Wake Word Detection client (OpenWakeWord)."""

    async def detect(self, audio_chunk: bytes) -> bool:
        """
        Detect wake word in audio chunk.

        Args:
            audio_chunk: Audio data chunk

        Returns:
            True if wake word detected
        """
        try:
            reader, writer = await self._connect()

            # Send audio chunk
            writer.write(struct.pack('<I', len(audio_chunk)))
            writer.write(audio_chunk)
            await writer.drain()

            # Read detection result (single byte: 0 or 1)
            result = await asyncio.wait_for(reader.readexactly(1), timeout=1.0)

            writer.close()
            await writer.wait_closed()

            return result[0] == 1

        except asyncio.TimeoutError:
            return False
        except Exception as e:
            logger.debug(f"Wake word detection error: {e}")
            return False
