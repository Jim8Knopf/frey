---
# ==============================================================================
# PHASE 1: START IMAGE DOWNLOADS IN BACKGROUND
# ==============================================================================
# Kickoff downloads for 12+ services immediately. These run in background
# while we do all the setup work below (audiobook bridge, qBittorrent, Step-CA).

- name: Start background image pulls for media stack
  include_tasks: "../playbooks/templates/async_prepull_start.yml"
  vars:
    stack: "media"
    service_dict: "{{ media.services }}"
    exclude_services: [mopidy, audiobook_bridge, jellystat_db]
    prepull_timeout: 300

# ==============================================================================
# PHASE 2: SETUP WORK (RUNS WHILE IMAGES DOWNLOAD)
# ==============================================================================

- name: Setup media stack user and directories
  include_tasks: "templates/create_user.yml"
  vars:
    stack: "media"
    folders: [movies, tv, music, audiobooks, podcasts, audiobook-bridge]
    checkVar: [media, storage.base_dir, media.user.name]

- name: Deploy audiobook bridge playback script
  ansible.builtin.template:
    src: audiobook-bridge/play_book.py.j2
    dest: "{{ storage.appdata_dir }}/audiobook-bridge/play_book.py"
    owner: "{{ media.user.name }}"
    group: "{{ media.group.name }}"
    mode: '0755'
  when: media.services.audiobook_bridge.enabled | default(false)

- name: Warn when Audiobookshelf API token is missing (disables audiobook-bridge integration)
  ansible.builtin.debug:
    msg: "audiobookshelf_api_token not defined — audiobook-bridge will deploy without API token. Add it to group_vars/all/secrets.yml to enable Audiobookshelf sync. Get token from Audiobookshelf Settings → Users → [Your User] → API Tokens."
  when:
    - media.services.audiobook_bridge.enabled | default(false)
    - audiobookshelf_api_token is not defined

# ==============================================================================
# STEP-CA CERTIFICATE MOUNT FIX
# ==============================================================================
# Fix broken directory mounts caused by Docker creating directories when
# certificate files don't exist yet. This happens when containers start
# before Step-CA has generated certificates.

- name: Check Step-CA root certificate file status
  ansible.builtin.stat:
    path: "{{ storage.appdata_dir }}/step-ca/certs/root_ca.crt"
  register: step_ca_cert_check
  when: media.services.audiobookshelf.enabled | default(false)

- name: Remove broken Step-CA cert directory mount (Docker created dir instead of file)
  ansible.builtin.file:
    path: "{{ storage.appdata_dir }}/step-ca/certs/root_ca.crt"
    state: absent
  when:
    - media.services.audiobookshelf.enabled | default(false)
    - step_ca_cert_check.stat.exists | default(false)
    - step_ca_cert_check.stat.isdir | default(false)

- name: Warn when Step-CA certificate not available for Audiobookshelf OIDC
  ansible.builtin.debug:
    msg: "Step-CA certificate not found — Audiobookshelf will deploy without CA trust. OIDC to https://auth.{{ network.domain_name }} may fail. Run playbook again after Step-CA initializes to add certificate mount."
  when:
    - media.services.audiobookshelf.enabled | default(false)
    - infrastructure.services.step_ca.enabled | default(false)
    - not (step_ca_cert_check.stat.exists | default(false) and step_ca_cert_check.stat.isreg | default(false))

- name: Set fact for Step-CA cert availability
  ansible.builtin.set_fact:
    step_ca_cert_available: "{{ step_ca_cert_check.stat.exists | default(false) and step_ca_cert_check.stat.isreg | default(false) }}"
  when: media.services.audiobookshelf.enabled | default(false)

- name: Ensure downloads directory exists with proper permissions
  ansible.builtin.file:
    path: "{{ media.downloads }}"
    state: directory
    owner: "{{ media.user.name }}"
    group: "{{ media.group.name }}"
    mode: '0775'

- name: Check if qBittorrent container exists
  community.docker.docker_container_info:
    name: "{{ media.services.qbittorrent.container_name }}"
  register: qbittorrent_container_info
  when: not media.vpn.enabled
  ignore_errors: true

- name: Stop qBittorrent container before config modification
  community.docker.docker_container:
    name: "{{ media.services.qbittorrent.container_name }}"
    state: stopped
  when:
    - not media.vpn.enabled
    - qbittorrent_container_info.exists is defined
    - qbittorrent_container_info.exists

- name: Ensure qBittorrent config directory exists
  ansible.builtin.file:
    path: "{{ storage.appdata_dir }}/qbittorrent/qBittorrent"
    state: directory
    owner: "{{ media.user.name }}"
    group: "{{ media.group.name }}"
    mode: '0775'
  when: not media.vpn.enabled

- name: Ensure qBittorrent logs directory exists
  ansible.builtin.file:
    path: "{{ storage.appdata_dir }}/qbittorrent/logs"
    state: directory
    owner: "{{ media.user.name }}"
    group: "{{ media.group.name }}"
    mode: '0775'
  when: not media.vpn.enabled

- name: Deploy qBittorrent healthcheck script
  ansible.builtin.copy:
    src: qbittorrent_healthcheck.sh
    dest: "{{ storage.appdata_dir }}/qbittorrent/healthcheck.sh"
    owner: "{{ media.user.name }}"
    group: "{{ media.group.name }}"
    mode: '0755'
  when: not media.vpn.enabled

- name: Deploy optimized qBittorrent configuration (only if not exists)
  ansible.builtin.template:
    src: qBittorrent.conf.j2
    dest: "{{ storage.appdata_dir }}/qbittorrent/qBittorrent/qBittorrent.conf"
    owner: "{{ media.user.name }}"
    group: "{{ media.group.name }}"
    mode: '0644'
    force: no
  when: not media.vpn.enabled

- name: Ensure qBittorrent download paths use container mount
  ansible.builtin.lineinfile:
    path: "{{ storage.appdata_dir }}/qbittorrent/qBittorrent/qBittorrent.conf"
    regexp: "^{{ item.key | regex_escape }}="
    line: "{{ item.key }}={{ item.value }}"
    backrefs: false
  loop:
    - { key: "Session\\SavePath", value: "/downloads" }
    - { key: "Session\\TempPath", value: "/downloads/incomplete" }
    - { key: "Downloads\\SavePath", value: "/downloads" }
    - { key: "Downloads\\TempPath", value: "/downloads/incomplete" }
    - { key: "FileLogger\\Path", value: "/config/logs" }
  when: not media.vpn.enabled

- name: Start qBittorrent container after config modification
  community.docker.docker_container:
    name: "{{ media.services.qbittorrent.container_name }}"
    state: started
  when:
    - not media.vpn.enabled
    - qbittorrent_container_info.exists is defined
    - qbittorrent_container_info.exists

- name: Ensure Step-CA root certificate is present for media mounts
  block:
    - name: Check Step-CA root certificate source
      ansible.builtin.stat:
        path: "{{ storage.appdata_dir }}/traefik/certificates/{{ infrastructure.services.step_ca.cert_files.root_ca }}"
      register: media_step_ca_src

    - name: Remove invalid Step-CA root source when it's a directory
      ansible.builtin.file:
        path: "{{ storage.appdata_dir }}/traefik/certificates/{{ infrastructure.services.step_ca.cert_files.root_ca }}"
        state: absent
      when:
        - media_step_ca_src.stat.isdir | default(false)
          or (media_step_ca_src.stat.exists | default(false)
              and (media_step_ca_src.stat.size | default(0) == 0))

    - name: Check Step-CA root certificate target
      ansible.builtin.stat:
        path: "{{ storage.appdata_dir }}/step-ca/certs/root_ca.crt"
      register: media_step_ca_dest

    - name: Remove invalid Step-CA root target when it's a directory
      ansible.builtin.file:
        path: "{{ storage.appdata_dir }}/step-ca/certs/root_ca.crt"
        state: absent
      when:
        - media_step_ca_dest.stat.isdir | default(false)
          or (media_step_ca_dest.stat.exists | default(false)
              and (media_step_ca_dest.stat.size | default(0) == 0))

    - name: Ensure Step-CA cert directory exists
      ansible.builtin.file:
        path: "{{ storage.appdata_dir }}/step-ca/certs"
        state: directory
        owner: 1000
        group: 1000
        mode: '0755'

    - name: Try exporting Step-CA root certificate when missing
      ansible.builtin.command:
        cmd: docker exec step-ca step ca root
      register: media_step_ca_export
      changed_when: false
      failed_when: false
      when:
        - not media_step_ca_src.stat.exists | default(false)

    - name: Write exported Step-CA root certificate when available
      ansible.builtin.copy:
        dest: "{{ storage.appdata_dir }}/traefik/certificates/{{ infrastructure.services.step_ca.cert_files.root_ca }}"
        content: "{{ media_step_ca_export.stdout }}"
        owner: "{{ infrastructure.user.name }}"
        group: "{{ infrastructure.group.name }}"
        mode: '0644'
      when:
        - not media_step_ca_src.stat.exists | default(false)
        - media_step_ca_export.rc == 0
        - media_step_ca_export.stdout is defined
        - media_step_ca_export.stdout | length > 0

    - name: Re-check Step-CA root certificate source
      ansible.builtin.stat:
        path: "{{ storage.appdata_dir }}/traefik/certificates/{{ infrastructure.services.step_ca.cert_files.root_ca }}"
      register: media_step_ca_src

    - name: Copy Step-CA root certificate for media mounts
      ansible.builtin.copy:
        src: "{{ storage.appdata_dir }}/traefik/certificates/{{ infrastructure.services.step_ca.cert_files.root_ca }}"
        dest: "{{ storage.appdata_dir }}/step-ca/certs/root_ca.crt"
        owner: 1000
        group: 1000
        mode: '0644'
        remote_src: true
      when: media_step_ca_src.stat.exists | default(false)

    - name: Fail early when Step-CA root certificate is missing
      ansible.builtin.fail:
        msg: "Step-CA root certificate missing at {{ storage.appdata_dir }}/traefik/certificates/{{ infrastructure.services.step_ca.cert_files.root_ca }}. Run the infrastructure role to generate it, then re-run media."
      when: not media_step_ca_src.stat.exists | default(false)

    - name: Verify Step-CA root certificate is a file
      ansible.builtin.stat:
        path: "{{ storage.appdata_dir }}/step-ca/certs/root_ca.crt"
      register: media_step_ca_verified
      failed_when: not media_step_ca_verified.stat.isreg
  when: media.services.audiobookshelf.enabled | default(false)

# ==============================================================================
# PHASE 3: WAIT FOR IMAGE DOWNLOADS TO COMPLETE
# ==============================================================================
# All setup work is done. Now wait for the background downloads from Phase 1.

- name: Wait for media stack images to finish downloading
  include_tasks: "../playbooks/templates/async_prepull_wait.yml"
  vars:
    stack: "media"
    prepull_retries: 120
    prepull_delay: 5

# ==============================================================================
# PHASE 4: DEPLOY STACK
# ==============================================================================

- name: Deploy media stack
  include_tasks: "../playbooks/templates/deploy_compose_stack.yml"
  vars:
    stack: "media"
    compose_template: "docker-compose-media.yml.j2"
    error_handling: "rescue"
    deploy_timeout: 300
    deploy_retries: 2
