networks:
  # Simplified network architecture
  proxy:
    external: true  # For Traefik routing
  backend:
    external: true  # Internal service communication

services:
  {% if media.vpn.enabled | default(false) -%}
    gluetun:
      image: qmcgaw/gluetun
      container_name: gluetun
      cap_add:
        - NET_ADMIN
      devices:
        - /dev/net/tun:/dev/net/tun # If running on an LXC see readme for more info.
      networks:
        proxy: {}        # Required for Traefik routing
        backend: {}      # Internal service communication
      # Only expose VPN port, other services should go through Traefik
      ports:
        - "{{ media.vpn.port }}:{{ media.vpn.port }}" # VPN forwarded port
      volumes:
        - {{ storage.appdata_dir }}/gluetun:/gluetun
      labels:
        - "traefik.enable=true"
        - "traefik.docker.network=proxy"
        - "traefik.http.routers.gluetun.rule=Host(`vpn.{{ network.domain_name }}`)"
        - "traefik.http.routers.gluetun.entrypoints=web"
        - "traefik.http.services.gluetun.loadbalancer.server.port={{ media.vpn.port }}"
      healthcheck:
        test: ["CMD-SHELL", "curl -f http://localhost:{{ media.vpn.port }} || exit 1"]
        interval: 30s
        timeout: 10s
        retries: 3
        start_period: 20s
      restart: unless-stopped
  {% endif %}

{% for service_name, service_config in media.services.items() if service_config.enabled and service_config.port is defined and service_config.port > 0 and service_name not in ['mopidy', 'audiobook_bridge'] %}
  {{ service_name }}:
    image: "{{ service_config.image }}:{{ service_config.version }}"
    container_name: {{ service_name }}
    environment:
{% for env_var in ([
  'PUID=' ~ media.user.uid|string,
  'PGID=' ~ media.group.gid|string,
  'TZ=' ~ network.timezone
] + (service_config.environment | default([]))) %}
      - {{ env_var }}
{% endfor %}
{% if service_name == 'qbittorrent' %}
{%   if qbittorrent_username is defined %}
      - QBT_USERNAME={{ qbittorrent_username }}
{%   endif %}
{%   if qbittorrent_password is defined %}
      - QBT_PASSWORD={{ qbittorrent_password | replace('$', '$$') }}
{%   endif %}
      - QBT_STALL_THRESHOLD={{ service_config.healthcheck.stall_threshold | default(300) }}
      - QBT_INTERNET_HOST={{ service_config.healthcheck.internet_host | default('1.1.1.1') }}
{% endif %}
{% set media_dns = media.dns_servers | default([]) %}
{% if media_dns | length > 0 %}
    dns:
{%   for dns_server in media_dns %}
      - {{ dns_server }}
{%   endfor %}
{% endif %}
    restart: unless-stopped
{% set service_volumes = service_config.volumes | default([]) %}
{% if service_volumes | length > 0 %}
    volumes:
{%   for volume in service_volumes %}
{%     if 'step-ca/certs/root_ca.crt' in volume %}
{%       if step_ca_cert_available | default(false) %}
      - {{ volume }}  # Step-CA cert available
{%       else %}
      # Skipping Step-CA cert mount (file not ready) - re-run playbook after Step-CA initializes
{%       endif %}
{%     else %}
      - {{ volume }}
{%     endif %}
{%   endfor %}
{% endif %}
{% if service_name == 'qbittorrent' %}
      - "{{ storage.appdata_dir }}/qbittorrent/healthcheck.sh:/healthcheck.sh:ro"
{% endif %}
    networks:
      proxy: {}        # Required for Traefik routing
      backend: {}      # Internal service communication
    ports:
{% if service_config.ports is defined %}
{% for port in service_config.ports %}
      - {{ port }}
{% endfor %}
{% else %}
      - "{{ service_config.port }}:{{ service_config.port }}"  # Direct access for library network
{% endif %}
{% if service_name == 'qbittorrent' %}
    healthcheck:
      test: ["CMD-SHELL", "/bin/bash /healthcheck.sh"]
      interval: {{ service_config.healthcheck.interval | default('60s') }}
      timeout: {{ service_config.healthcheck.timeout | default('10s') }}
      retries: {{ service_config.healthcheck.retries | default(3) }}
      start_period: {{ service_config.healthcheck.start_period | default('60s') }}
{% endif %}
    labels:
      - deunhealth.restart.on.unhealthy=true
      - "traefik.enable=true"
      - "traefik.docker.network=proxy"
      - "traefik.http.routers.{{service_name}}.rule=Host(`{{service_name}}.{{ network.domain_name }}`)"
      - "traefik.http.routers.{{service_name}}.entrypoints=web,websecure"
      - "traefik.http.routers.{{service_name}}.tls=true"
      - "traefik.http.routers.{{service_name}}.tls.certresolver=step-ca"
      - "traefik.http.services.{{service_name}}.loadbalancer.server.port={{ service_config.internal_port | default(service_config.port) }}"
{# Authelia forward auth removed - *arr services use built-in authentication for web UI + API access #}

{% endfor -%}

  {% if media.services.mopidy.enabled | default(false) -%}
  # Mopidy - Music Player Daemon with Jellyfin integration for tag-based playback
  mopidy1:
    image: "{{ media.services.mopidy.image | default('wernight/mopidy') }}:{{ media.services.mopidy.version | default('latest') }}"
    container_name: mopidy
    restart: unless-stopped
    ports:
      - "{{ media.services.mopidy.mpd_port | default(6600) }}:6600"  # MPD protocol
      - "{{ media.services.mopidy.http_port | default(6680) }}:6680"  # HTTP/Mopidy-Web
    volumes:
      - "{{ storage.appdata_dir }}/mopidy:/var/lib/mopidy"
      - "{{ media.dir }}:/media:ro"
    environment:
      - PULSE_SERVER=unix:/run/user/1000/pulse/native
      - MOPIDY_JELLYFIN_HOSTNAME=jellyfin.{{ network.domain_name }}
      - MOPIDY_JELLYFIN_TOKEN={{ jellyfin_api_token }}
    devices:
      - /dev/snd:/dev/snd  # Audio output for local playback
    networks:
      proxy: {}
      backend: {}
    labels:
      - "traefik.enable=true"
      - "traefik.docker.network=proxy"
      - "traefik.http.routers.mopidy.rule=Host(`mopidy.{{ network.domain_name }}`)"
      - "traefik.http.routers.mopidy.entrypoints=web"
      - "traefik.http.services.mopidy.loadbalancer.server.port=6680"
  {% endif %}

  {% if media.services.audiobook_bridge.enabled | default(false) -%}
  # Audiobook Bridge - Local audiobook playback with progress sync to Audiobookshelf
  # Usage: docker exec audiobook-bridge python3 /app/play_book.py --book-id <ID>
  audiobook-bridge1:
    image: "{{ media.services.audiobook_bridge.image }}:{{ media.services.audiobook_bridge.version }}"
    container_name: audiobook-bridge
    restart: unless-stopped
    volumes:
      - "{{ storage.appdata_dir }}/audiobook-bridge:/app"
      - "{{ media.dir }}/audiobooks:/audiobooks:ro"
    environment:
      - AUDIOBOOKSHELF_URL=http://audiobookshelf:{{ media.services.audiobookshelf.port | default(13378) }}
{%   if audiobookshelf_api_token is defined -%}
      - AUDIOBOOKSHELF_TOKEN={{ audiobookshelf_api_token }}
{%   endif %}
      - SYNC_INTERVAL={{ media.services.audiobook_bridge.sync_interval | default(5) }}
    devices:
      - /dev/snd:/dev/snd  # Audio output for local playback
    command: >
      sh -c "apt-get update && apt-get install -y mpv &&
             pip install requests &&
             tail -f /dev/null"
    networks:
      backend: {}
    labels:
      - "traefik.enable=false"  # Internal service only
  {% endif %}

  # See the 'qBittorrent Stalls with VPN Timeout' section for more information.
  deunhealth:
    image: qmcgaw/deunhealth
    container_name: deunhealth
    network_mode: "none"
    environment:
      - LOG_LEVEL=info
      - HEALTH_SERVER_ADDRESS=127.0.0.1:9999
      - TZ={{ network.timezone }}
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

# End of file.
