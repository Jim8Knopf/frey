#!/bin/bash
# ==============================================================================
# FREY NAT MANAGER - Dynamic Internet Passthrough
# ==============================================================================
# Automatically configures NAT/MASQUERADE for WiFi AP clients when upstream
# internet connection becomes available (LAN or public WiFi).
#
# FEATURES:
# - Detects upstream connectivity automatically
# - Enables NAT when LAN plugged in or connected to public WiFi
# - Disables NAT when offline (graceful degradation)
# - Logs all changes for troubleshooting
# - Runs continuously, checking every 10 seconds
#
# USE CASES:
# - Boot offline: FreyHub works, no internet passthrough
# - Plug LAN cable: Auto-enables internet for WiFi clients
# - Connect to cafe WiFi: Auto-switches to WiFi passthrough
# - Disconnect: Returns to offline mode gracefully
# ==============================================================================

# Configuration
WIFI_AP_INTERFACE="{{ network.wifi.interface }}"
WIFI_AP_NETWORK="{{ network.wifi.network }}"
FORCE_DNS_IP="{{ network.wifi.ip }}"
CHECK_INTERVAL=10
LOG_FILE="/var/log/frey-nat-manager.log"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Check if NAT rule exists for specific interface
nat_rule_exists() {
    local interface=$1
    iptables -t nat -C POSTROUTING -s "$WIFI_AP_NETWORK" -o "$interface" -j MASQUERADE 2>/dev/null
    return $?
}

# Enable NAT for upstream interface
enable_nat() {
    local upstream=$1

    # Enable IP forwarding
    if [ "$(sysctl -n net.ipv4.ip_forward)" != "1" ]; then
        sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1
        log "Enabled IP forwarding"
    fi

    # Check if rule already exists
    if nat_rule_exists "$upstream"; then
        return 0  # Already configured
    fi

    # Clean any old rules first
    iptables -t nat -D POSTROUTING -s "$WIFI_AP_NETWORK" -j MASQUERADE 2>/dev/null || true

    # Add MASQUERADE rule for new upstream
    if iptables -t nat -A POSTROUTING -s "$WIFI_AP_NETWORK" -o "$upstream" -j MASQUERADE; then
        log "✓ NAT enabled: WiFi clients ({{ network.wifi.network }}) → Internet via $upstream"

        # Add FORWARD chain rules
        iptables -A FORWARD -i "$WIFI_AP_INTERFACE" -o "$upstream" -j ACCEPT 2>/dev/null || true
        iptables -A FORWARD -i "$upstream" -o "$WIFI_AP_INTERFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true

        return 0
    else
        log "✗ Failed to enable NAT for $upstream"
        return 1
    fi
}

# Disable NAT
disable_nat() {
    # Remove MASQUERADE rule
    if iptables -t nat -D POSTROUTING -s "$WIFI_AP_NETWORK" -j MASQUERADE 2>/dev/null; then
        log "✓ NAT disabled: Offline mode (no internet passthrough)"
    fi

    # Clean FORWARD rules
    iptables -D FORWARD -i "$WIFI_AP_INTERFACE" -j ACCEPT 2>/dev/null || true
    iptables -D FORWARD -o "$WIFI_AP_INTERFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
}

# Get current upstream interface (interface with default route)
get_upstream_interface() {
    # Find interface with default route, exclude wlan1 (our AP)
    local upstream=$(ip route | grep '^default' | awk '{print $5}' | grep -v "^$WIFI_AP_INTERFACE$" | head -1)
    echo "$upstream"
}

# Check if interface has internet connectivity
has_internet() {
    local interface=$1
    # Check if interface is UP and has an IP
    if ip addr show "$interface" 2>/dev/null | grep -q "inet "; then
        return 0
    fi
    return 1
}

# Force AP clients to use local DNS (redirect TCP/UDP 53 to dnsmasq on the Pi)
ensure_force_dns_rules() {
    if ! iptables -t nat -C PREROUTING -i "$WIFI_AP_INTERFACE" -p udp --dport 53 -j DNAT --to-destination "$FORCE_DNS_IP":53 2>/dev/null; then
        if iptables -t nat -A PREROUTING -i "$WIFI_AP_INTERFACE" -p udp --dport 53 -j DNAT --to-destination "$FORCE_DNS_IP":53; then
            log "✓ Forced UDP DNS to $FORCE_DNS_IP:53 for AP clients"
        fi
    fi

    if ! iptables -t nat -C PREROUTING -i "$WIFI_AP_INTERFACE" -p tcp --dport 53 -j DNAT --to-destination "$FORCE_DNS_IP":53 2>/dev/null; then
        if iptables -t nat -A PREROUTING -i "$WIFI_AP_INTERFACE" -p tcp --dport 53 -j DNAT --to-destination "$FORCE_DNS_IP":53; then
            log "✓ Forced TCP DNS to $FORCE_DNS_IP:53 for AP clients"
        fi
    fi
}

# Main monitoring loop
log "========================================="
log "Frey NAT Manager started"
log "WiFi AP: $WIFI_AP_INTERFACE ($WIFI_AP_NETWORK)"
log "========================================="

LAST_UPSTREAM=""
UPSTREAM_STABLE_COUNT=0  # Count stable detections before enabling NAT
UPSTREAM_STABILITY_THRESHOLD=3  # Require 3 consecutive detections (30s)

while true; do
    # Ensure DNS pinning stays in place so clients resolve *.frey locally even when offline
    ensure_force_dns_rules

    # Get current upstream interface
    CURRENT_UPSTREAM=$(get_upstream_interface)

    # Check if upstream changed
    if [ "$CURRENT_UPSTREAM" != "$LAST_UPSTREAM" ]; then
        # Reset stability counter on change
        UPSTREAM_STABLE_COUNT=0

        if [ -n "$CURRENT_UPSTREAM" ]; then
            log "Detected upstream change: $LAST_UPSTREAM → $CURRENT_UPSTREAM (waiting for stability...)"
        else
            # No upstream - disable NAT immediately
            if [ -n "$LAST_UPSTREAM" ]; then
                log "Lost upstream: $LAST_UPSTREAM"
                disable_nat
                LAST_UPSTREAM=""
            fi
        fi
    else
        # Upstream stable - increment counter
        if [ -n "$CURRENT_UPSTREAM" ] && [ -z "$LAST_UPSTREAM" ]; then
            UPSTREAM_STABLE_COUNT=$((UPSTREAM_STABLE_COUNT + 1))

            if [ "$UPSTREAM_STABLE_COUNT" -ge "$UPSTREAM_STABILITY_THRESHOLD" ]; then
                # Upstream stable for 30 seconds, enable NAT
                if has_internet "$CURRENT_UPSTREAM"; then
                    enable_nat "$CURRENT_UPSTREAM"
                    LAST_UPSTREAM="$CURRENT_UPSTREAM"
                    UPSTREAM_STABLE_COUNT=0
                fi
            else
                log "Upstream $CURRENT_UPSTREAM stable ($UPSTREAM_STABLE_COUNT/$UPSTREAM_STABILITY_THRESHOLD checks)"
            fi
        fi
    fi

    # Sleep before next check
    sleep "$CHECK_INTERVAL"
done
