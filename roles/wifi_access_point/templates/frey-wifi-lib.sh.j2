#!/bin/bash
# ==============================================================================
# FREY WIFI LIBRARY - Shared Functions for WiFi Scripts
# ==============================================================================
# Common functions used across all Frey WiFi management scripts.
# Source this file at the beginning of your scripts:
#   source /usr/local/lib/frey/frey-wifi-lib.sh
# ==============================================================================

# ------------------------------------------------------------------------------
# Color Definitions
# ------------------------------------------------------------------------------
export RED='\033[0;31m'
export GREEN='\033[0;32m'
export YELLOW='\033[1;33m'
export BLUE='\033[0;34m'
export NC='\033[0m'  # No Color

# ------------------------------------------------------------------------------
# Logging Functions (Console Output)
# ------------------------------------------------------------------------------

log() {
    echo -e "${GREEN}[$(date '+%H:%M:%S')]${NC} $*"
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

# Aliases for backward compatibility
info() { log_info "$@"; }
warn() { log_warning "$@"; }
error() { log_error "$@"; }

# ------------------------------------------------------------------------------
# Logging Functions (System Logger)
# ------------------------------------------------------------------------------

log_to_system() {
    local tag="${1:-frey-wifi}"
    shift
    logger -t "$tag" "$*"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# ------------------------------------------------------------------------------
# Root Check
# ------------------------------------------------------------------------------

require_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "This script requires root privileges"
        log_info "Please run with: sudo $0"
        exit 1
    fi
}

# ------------------------------------------------------------------------------
# Interface Validation
# ------------------------------------------------------------------------------

validate_interface() {
    local interface="$1"

    if [ -z "$interface" ]; then
        log_error "Interface name not provided"
        return 1
    fi

    if ! ip link show "$interface" &>/dev/null; then
        log_error "Interface $interface does not exist"
        log_info "Available interfaces:"
        ip link show | grep -E '^[0-9]+: ' | awk '{print "  " $2}' | sed 's/:$//'
        return 1
    fi

    return 0
}

interface_exists() {
    local interface="$1"
    ip link show "$interface" &>/dev/null
}

bring_interface_up() {
    local interface="$1"

    if ! validate_interface "$interface"; then
        return 1
    fi

    log "Bringing $interface up..."
    ip link set "$interface" up
}

bring_interface_down() {
    local interface="$1"

    if ! validate_interface "$interface"; then
        return 1
    fi

    log "Bringing $interface down..."
    ip link set "$interface" down 2>/dev/null || true
}

# ------------------------------------------------------------------------------
# WPA Supplicant Management
# ------------------------------------------------------------------------------

wpa_cli_cmd() {
    local interface="$1"
    shift
    wpa_cli -i "$interface" "$@" 2>/dev/null
}

get_wpa_status() {
    local interface="$1"
    wpa_cli_cmd "$interface" status
}

wpa_connect() {
    local interface="$1"
    local ssid="$2"

    log "Connecting to $ssid..."
    wpa_cli_cmd "$interface" select_network "$(wpa_cli_cmd "$interface" list_networks | grep "$ssid" | awk '{print $1}')"
}

wpa_disconnect() {
    local interface="$1"

    log "Disconnecting wpa_supplicant..."
    wpa_cli_cmd "$interface" disconnect || true
}

wpa_reconnect() {
    local interface="$1"

    log "Reconnecting wpa_supplicant..."
    wpa_cli_cmd "$interface" reconnect || true
}

is_wpa_supplicant_running() {
    local interface="$1"
    pgrep -f "wpa_supplicant.*$interface" >/dev/null
}

kill_wpa_supplicant() {
    local interface="$1"

    if is_wpa_supplicant_running "$interface"; then
        log_warning "Stopping existing wpa_supplicant on $interface..."
        pkill -f "wpa_supplicant.*$interface" || true
        sleep 1
    fi
}

# ------------------------------------------------------------------------------
# DHCP Management (dhcpcd)
# ------------------------------------------------------------------------------

restart_dhcp() {
    local interface="$1"

    log "Requesting DHCP lease on $interface..."
    dhcpcd -n "$interface" 2>/dev/null || true
}

release_dhcp() {
    local interface="$1"

    log "Releasing DHCP lease on $interface..."
    dhcpcd -k "$interface" 2>/dev/null || true
}

is_dhcpcd_running() {
    local interface="$1"
    pgrep -f "dhcpcd.*$interface" >/dev/null
}

kill_dhcpcd() {
    local interface="$1"

    if is_dhcpcd_running "$interface"; then
        log "Stopping dhcpcd on $interface..."
        release_dhcp "$interface"
    fi
}

# ------------------------------------------------------------------------------
# Service Health Checks
# ------------------------------------------------------------------------------

check_service_active() {
    local service="$1"
    systemctl is-active --quiet "$service"
}

check_service_enabled() {
    local service="$1"
    systemctl is-enabled --quiet "$service"
}

restart_service_safe() {
    local service="$1"
    local tag="${2:-frey-service}"

    log_info "Restarting $service..."

    if systemctl restart "$service" 2>/dev/null; then
        log_success "$service restarted successfully"
        log_to_system "$tag" "SUCCESS: $service restarted successfully"
        return 0
    else
        log_error "Failed to restart $service"
        log_to_system "$tag" "CRITICAL: $service restart FAILED - requires manual intervention"
        return 1
    fi
}

check_and_restart_service() {
    local service="$1"
    local tag="${2:-frey-service}"

    if ! check_service_active "$service"; then
        log_error "$service is NOT active - restarting..."
        log_to_system "$tag" "ERROR: $service is NOT active - restarting..."

        restart_service_safe "$service" "$tag"
        sleep 2

        if check_service_active "$service"; then
            return 0
        else
            return 1
        fi
    fi

    return 0
}

# ------------------------------------------------------------------------------
# Network Connectivity Checks
# ------------------------------------------------------------------------------

check_internet_connectivity() {
    local target="${1:-1.1.1.1}"
    local interface="${2:-}"
    local count="${3:-2}"

    if [ -n "$interface" ]; then
        ping -I "$interface" -c "$count" -W 3 "$target" >/dev/null 2>&1
    else
        ping -c "$count" -W 3 "$target" >/dev/null 2>&1
    fi
}

check_dns_resolution() {
    local hostname="${1:-google.com}"

    nslookup "$hostname" >/dev/null 2>&1 || \
    host "$hostname" >/dev/null 2>&1 || \
    dig "$hostname" >/dev/null 2>&1
}

# ------------------------------------------------------------------------------
# Network Interface Information
# ------------------------------------------------------------------------------

get_interface_ip() {
    local interface="$1"

    ip -4 addr show "$interface" 2>/dev/null | \
        grep -oP '(?<=inet\s)\d+(\.\d+){3}' | \
        head -n 1
}

has_ip_address() {
    local interface="$1"
    local expected_ip="${2:-}"

    local current_ip
    current_ip=$(get_interface_ip "$interface")

    if [ -z "$current_ip" ]; then
        return 1
    fi

    if [ -n "$expected_ip" ]; then
        [ "$current_ip" = "$expected_ip" ]
    else
        return 0
    fi
}

get_interface_state() {
    local interface="$1"

    ip link show "$interface" 2>/dev/null | \
        grep -oP '(?<=state )\w+' | \
        head -n 1
}

is_interface_up() {
    local interface="$1"
    local state

    state=$(get_interface_state "$interface")
    [ "$state" = "UP" ] || [ "$state" = "UNKNOWN" ]
}

# ------------------------------------------------------------------------------
# Hostapd Management
# ------------------------------------------------------------------------------

is_hostapd_responding() {
    local interface="$1"

    hostapd_cli -i "$interface" ping >/dev/null 2>&1
}

get_hostapd_stations() {
    local interface="$1"

    hostapd_cli -i "$interface" all_sta 2>/dev/null
}

count_hostapd_stations() {
    local interface="$1"

    get_hostapd_stations "$interface" | grep -c "^[0-9a-f][0-9a-f]:" || echo "0"
}

# ------------------------------------------------------------------------------
# Process Management
# ------------------------------------------------------------------------------

is_process_running() {
    local pattern="$1"
    pgrep -f "$pattern" >/dev/null
}

kill_process_pattern() {
    local pattern="$1"

    if is_process_running "$pattern"; then
        pkill -f "$pattern" || true
        sleep 1
    fi
}

# ------------------------------------------------------------------------------
# File Operations
# ------------------------------------------------------------------------------

ensure_directory() {
    local dir="$1"
    local mode="${2:-0755}"

    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
        chmod "$mode" "$dir"
    fi
}

# ------------------------------------------------------------------------------
# Signal Handling
# ------------------------------------------------------------------------------

setup_signal_handlers() {
    local pause_handler="$1"
    local resume_handler="$2"

    trap "$pause_handler" SIGUSR1
    trap "$resume_handler" SIGUSR2
}

# ------------------------------------------------------------------------------
# Library Initialization
# ------------------------------------------------------------------------------

# Set umask for security
umask 022

# Export functions for subshells (optional, usually not needed with source)
# export -f log log_info log_success log_warning log_error
# export -f validate_interface wpa_cli_cmd restart_dhcp release_dhcp
# export -f check_service_active restart_service_safe
