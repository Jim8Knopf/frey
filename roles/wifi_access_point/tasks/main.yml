---
# roles/wifi_access_point/tasks/main.yml
# Final clean single-document tasks for AP bring-up.

- name: Assert required wifi variables are defined
  ansible.builtin.assert:
    that:
      - network.wifi.interface is defined
      - network.wifi.client_interface is defined
      - network.wifi.ssid is defined
      - network.wifi.password is defined
      - network.wifi.ip is defined
      - network.wifi.dhcp_range_start is defined
      - network.wifi.dhcp_range_end is defined
    msg: "Required wifi_access_point variables missing. See roles/wifi_access_point/README.md"

- name: Fail if attempting to configure the control interface (avoid disconnecting admin)
  ansible.builtin.fail:
    msg: "Refusing to modify {{ network.wifi.interface }} because it matches the control interface {{ ansible_default_ipv4.interface }}. Set network.wifi.interface to a secondary adapter (e.g. wlan1) or set force_apply=true to override."
  when:
    - (network.wifi.interface == ansible_default_ipv4.interface) and (force_apply | default(false) | bool) == false

- name: Fail if AP and client interfaces are identical
  ansible.builtin.fail:
    msg: "Refusing to configure hostapd and wpa_supplicant on the same interface ({{ network.wifi.interface }}). Set network.wifi.interface and network.wifi.client_interface to different adapters or set force_apply=true if you really want to share one NIC."
  when:
    - (network.wifi.client_interface | default('')) == (network.wifi.interface | default(''))
    - (force_apply | default(false) | bool) == false

# ==============================================================================
# Pre-Flight Hardware Validation
# ==============================================================================
# Verify physical WiFi interfaces exist before attempting deployment

- name: Verify AP interface exists
  ansible.builtin.command:
    cmd: ip link show {{ network.wifi.interface }}
  register: ap_interface_check
  changed_when: false
  failed_when: false
  tags:
    - wifi_ap
    - pre_flight

- name: Verify client interface exists
  ansible.builtin.command:
    cmd: ip link show {{ network.wifi.client_interface }}
  register: client_interface_check
  changed_when: false
  failed_when: false
  tags:
    - wifi_ap
    - pre_flight

# DISABLED FOR HOT-PLUG SUPPORT: Allow deployment without wlan1 present
# Services will use ConditionPathExists to gracefully skip when interface missing
# - name: Fail if AP interface missing (physical adapter mode)
#   ansible.builtin.fail:
#     msg: |
#       CRITICAL: AP interface {{ network.wifi.interface }} not found!
#
#       Expected interface: {{ network.wifi.interface }}
#       Available interfaces:
#       {{ ansible_interfaces | join(', ') }}
#
#       This usually means:
#       1. No secondary WiFi adapter is connected
#       2. WiFi driver not loaded (check: lsmod | grep brcmfmac)
#       3. Hardware failure
#
#       SOLUTIONS:
#       - Connect a USB WiFi adapter
#       - Enable virtual AP mode: network.wifi.virtual_ap.enabled: true
#       - Use different interface: network.wifi.interface: wlan0
#   when:
#     - not (network.wifi.virtual_ap.enabled | default(false))
#     - ap_interface_check.rc != 0
#   tags:
#     - wifi_ap
#     - pre_flight

- name: Fail if client interface missing
  ansible.builtin.fail:
    msg: |
      CRITICAL: Client interface {{ network.wifi.client_interface }} not found!

      Expected interface: {{ network.wifi.client_interface }}
      Available interfaces:
      {{ ansible_interfaces | join(', ') }}

      This usually means:
      1. WiFi interface name changed (check: ip link)
      2. WiFi driver not loaded
      3. Hardware failure

      SOLUTION: Update network.wifi.client_interface to match actual interface name
  when:
    - client_interface_check.rc != 0
    - network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_ap
    - pre_flight

# ==============================================================================
# NetworkManager Transition Detection & Staging
# ==============================================================================
# Fresh Raspberry Pi OS uses NetworkManager. We need to transition to dhcpcd
# without breaking the active SSH connection. This is done in two phases:
#   Phase 1: Stage configuration, create transition service, require reboot
#   Phase 2: After reboot (on dhcpcd), continue with full AP setup
# ==============================================================================

- name: Check if NetworkManager is active
  ansible.builtin.systemd:
    name: NetworkManager
  register: networkmanager_status
  failed_when: false
  changed_when: false

- name: Check if NetworkManager is managing the client interface
  ansible.builtin.shell: |
    nmcli -t -f DEVICE,STATE device status | grep "^{{ network.wifi.client_interface }}:connected"
  register: nm_manages_interface
  failed_when: false
  changed_when: false

- name: Check if dhcpcd is already active
  ansible.builtin.systemd:
    name: dhcpcd
  register: dhcpcd_status
  failed_when: false
  changed_when: false

- name: Set NetworkManager transition requirement fact
  ansible.builtin.set_fact:
    nm_transition_required: >-
      {{
        (networkmanager_status.status is defined and
         networkmanager_status.status.ActiveState == 'active' and
         nm_manages_interface.rc == 0) and
        (dhcpcd_status.status is not defined or
         dhcpcd_status.status.ActiveState != 'active')
      }}

- name: NetworkManager Transition Block
  when: nm_transition_required | bool
  block:
    - name: Create a fact to indicate systemd-resolved exists
      ansible.builtin.set_fact:
        systemd_resolved_exists: "{{ ansible_facts.services['systemd-resolved.service'] is defined and ansible_facts.services['systemd-resolved.service'].status.LoadState == \"loaded\" }}"
      delegate_to: localhost # Run on controller
      changed_when: false
    - name: Inform about NetworkManager transition
      ansible.builtin.debug:
        msg: |
          ========================================
          NETWORKMANAGER DETECTED
          ========================================
          Fresh Raspberry Pi OS installation detected.
          Staging transition from NetworkManager to dhcpcd+wpa_supplicant.
          This requires a reboot to complete safely.
          ========================================

    - name: Get current WiFi SSID from NetworkManager
      ansible.builtin.shell: |
        nmcli -t -f active,ssid dev wifi | grep '^yes:' | head -n1 | cut -d: -f2
      register: nm_current_ssid
      changed_when: false
      failed_when: false

    - name: Get NetworkManager connection UUID for current SSID
      ansible.builtin.shell: |
        nmcli -t -f NAME,UUID connection show | grep "^{{ nm_current_ssid.stdout }}:" | head -n1 | cut -d: -f2
      register: nm_connection_uuid
      when: nm_current_ssid.stdout | length > 0
      changed_when: false
      failed_when: false

    - name: Get current WiFi password from NetworkManager by UUID
      ansible.builtin.shell: |
        nmcli -s -g 802-11-wireless-security.psk connection show uuid "{{ nm_connection_uuid.stdout }}"
      register: nm_current_password
      when:
        - nm_current_ssid.stdout | length > 0
        - nm_connection_uuid.stdout | length > 0
      changed_when: false
      failed_when: false
      no_log: true

    - name: Determine WiFi credentials source
      ansible.builtin.set_fact:
        wifi_ssid_to_use: "{{ nm_current_ssid.stdout if (nm_current_ssid.stdout | length > 0) else (network.wifi.client_ssid | default('')) }}"
        wifi_password_to_use: "{{ nm_current_password.stdout if (nm_current_password.stdout is defined and nm_current_password.stdout | length > 0) else (network.wifi.client_password | default('')) }}"
      no_log: true

    - name: Verify WiFi credentials are available
      ansible.builtin.assert:
        that:
          - wifi_ssid_to_use | length > 0
          - wifi_password_to_use | length > 0
        msg: |
          ERROR: WiFi credentials not found!

          Neither NetworkManager connection nor group_vars contain WiFi credentials.

          Please add to group_vars/all/main.yml or secrets.yml:
            network:
              wifi:
                client_ssid: "YOUR_WIFI_SSID"
                client_password: "YOUR_WIFI_PASSWORD"

    - name: Test WiFi credentials BEFORE committing to transition
      block:
        # Use wpa_passphrase to validate credentials without touching the live network interface
        # This is SAFE - it only generates PSK, doesn't connect to anything
        - name: Validate WiFi credentials using wpa_passphrase
          ansible.builtin.shell: |
            wpa_passphrase "{{ wifi_ssid_to_use }}" "{{ wifi_password_to_use }}"
          register: wpa_test
          failed_when: false
          changed_when: false
          no_log: true

        - name: Warn if credential validation failed
          ansible.builtin.debug:
            msg: |
              WARNING: WiFi credential validation failed with exit code {{ wpa_test.rc }}

              This may indicate invalid WiFi passphrase format.
              Proceeding with transition, but you may lose SSH access after reboot.

              If you have issues after reboot, check:
              - SSID is correct: "{{ wifi_ssid_to_use }}"
              - Password length is >= 8 characters
              - Password doesn't contain special characters that need escaping
          when: wpa_test.rc != 0

    # Install required packages before staging configuration
    - name: Install packages required for NetworkManager transition
      ansible.builtin.apt:
        name:
          - dhcpcd5
          - wpasupplicant
          - hostapd
          - dnsmasq
          - rfkill
          - iw
        state: present
        update_cache: yes

    - name: Deploy dhcpcd configuration (staged)
      ansible.builtin.template:
        src: dhcpcd.conf.j2
        dest: /etc/dhcpcd.conf
        mode: '0644'
        backup: yes

    - name: Create wpa_supplicant config using template (with known_networks)
      ansible.builtin.template:
        src: wpa_supplicant-wlan0.conf.j2
        dest: "/etc/wpa_supplicant/wpa_supplicant-{{ network.wifi.client_interface }}.conf"
        mode: '0600'
      when: network.wifi.roaming.known_networks is defined
      no_log: true

    - name: Create fallback wpa_supplicant config (current network only)
      ansible.builtin.copy:
        content: |
          ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
          update_config=1
          country={{ network.wifi.country | default('AU') }}
          ap_scan=1

          network={
              ssid="{{ wifi_ssid_to_use }}"
              psk="{{ wifi_password_to_use }}"
              priority=100
          }
        dest: "/etc/wpa_supplicant/wpa_supplicant-{{ network.wifi.client_interface }}.conf"
        mode: '0600'
      when: network.wifi.roaming.known_networks is not defined
      no_log: true

    - name: Enable dhcpcd service (staged, will start after reboot)
      ansible.builtin.systemd:
        name: dhcpcd
        enabled: yes
        daemon_reload: yes

    - name: Create wpa_supplicant service override directory
      ansible.builtin.file:
        path: "/etc/systemd/system/wpa_supplicant@{{ network.wifi.client_interface }}.service.d"
        state: directory
        mode: '0755'

    - name: Create wpa_supplicant service override with driver specification
      ansible.builtin.copy:
        content: |
          [Service]
          ExecStart=
          # Add -t for timestamps and -d for debug logging so transition failures are visible in journal
          ExecStart=/usr/sbin/wpa_supplicant -t -d -Dnl80211,wext -c/etc/wpa_supplicant/wpa_supplicant-%I.conf -i%I
        dest: "/etc/systemd/system/wpa_supplicant@{{ network.wifi.client_interface }}.service.d/override.conf"
        mode: '0644'

    - name: Enable wpa_supplicant for client interface (staged)
      ansible.builtin.systemd:
        name: "wpa_supplicant@{{ network.wifi.client_interface }}"
        enabled: yes
        daemon_reload: yes

    - name: Create NetworkManager transition service
      ansible.builtin.copy:
        content: |
          [Unit]
          Description=Transition from NetworkManager to dhcpcd+wpa_supplicant
          After=network-pre.target sysinit.target
          Before=network-online.target
          DefaultDependencies=no
          ConditionPathExists=/etc/systemd/system/nm-transition.service

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          TimeoutStartSec=180

          # Phase 0: Pre-transition cleanup and DNS fallback
          ExecStart=/bin/bash -c 'if [ -L /etc/resolv.conf ]; then rm /etc/resolv.conf; echo "nameserver 8.8.8.8" > /etc/resolv.conf; fi'
          ExecStart=/bin/systemctl disable NetworkManager-wait-online.service
          ExecStart=/bin/systemctl disable NetworkManager-dispatcher.service
          ExecStart=/bin/systemctl stop NetworkManager-wait-online.service
          ExecStart=/bin/systemctl stop NetworkManager-dispatcher.service

          # Phase 1: Stop NetworkManager gracefully
          ExecStart=/bin/systemctl stop NetworkManager
          ExecStart=/bin/bash -c 'systemctl is-active --quiet systemd-resolved && systemctl stop systemd-resolved || true'

          # Phase 1.5: Unblock WiFi and bring up the interface (Critical: NetworkManager may leave it disabled)
          ExecStart=/usr/sbin/rfkill unblock wifi
          ExecStart=/sbin/ip link set {{ network.wifi.client_interface }} up
          ExecStart=/bin/bash -c 'sleep 2; echo "Interface {{ network.wifi.client_interface }} state:"; ip link show {{ network.wifi.client_interface }} | grep -o "state [A-Z]*"'

          # Phase 2: Start wpa_supplicant for client interface
          ExecStart=/bin/systemctl start wpa_supplicant@{{ network.wifi.client_interface }}

          # Phase 2.5: Trigger scan and show initial status
          ExecStart=/bin/bash -c 'sleep 3; wpa_cli -i {{ network.wifi.client_interface }} reconfigure >/dev/null 2>&1; wpa_cli -i {{ network.wifi.client_interface }} scan >/dev/null 2>&1 || true; wpa_cli -i {{ network.wifi.client_interface }} status || true'

          # Phase 3: Wait for WiFi association (up to 60 seconds), logging state each second
          ExecStart=/bin/bash -c 'echo "Waiting for WiFi association..."; for i in {1..60}; do state=$(wpa_cli -i {{ network.wifi.client_interface }} status 2>/dev/null | grep "^wpa_state=" | cut -d= -f2); echo "  [$i] state=${state:-unknown}"; if [ "$state" = "COMPLETED" ]; then echo "WiFi associated!"; exit 0; fi; sleep 1; done; echo "ERROR: WiFi association failed"; exit 1'

          # Phase 4: Start dhcpcd
          ExecStart=/bin/systemctl start dhcpcd

          # Phase 5: Wait for IP address (up to 60 seconds)
          ExecStart=/bin/bash -c 'echo "Waiting for IP address..."; for i in {1..60}; do if ip addr show {{ network.wifi.client_interface }} | grep -q "inet "; then echo "IP acquired!"; ip addr show {{ network.wifi.client_interface }} | grep "inet "; exit 0; fi; sleep 1; done; echo "ERROR: No IP address"; exit 1'

          # Phase 6: Validate network connectivity
          ExecStart=/bin/bash -c 'echo "=== Network Validation ==="; echo "WiFi State:"; wpa_cli -i {{ network.wifi.client_interface }} status | grep wpa_state; echo "IP Address:"; ip addr show {{ network.wifi.client_interface }} | grep "inet "; echo "Default Route:"; ip route | grep default; echo "Internet Test:"; (ping -c 1 -W 5 8.8.8.8 && echo "Internet: OK") || echo "WARNING: No internet (may be captive portal)"; echo "=== Validation Complete ==="'

          # Phase 7: Only mask services after successful network restoration
          ExecStart=/bin/systemctl mask NetworkManager
          ExecStart=/bin/bash -c 'systemctl list-unit-files systemd-resolved.service >/dev/null 2>&1 && systemctl mask systemd-resolved || true'
          ExecStart=/bin/systemctl mask wpa_supplicant

          # Phase 8: Disable this transition service
          ExecStart=/bin/systemctl disable nm-transition.service

          # Rollback on failure
          ExecStopPost=/bin/bash -c 'if [ "$SERVICE_RESULT" != "success" ]; then echo "TRANSITION FAILED - Rolling back..."; systemctl stop dhcpcd; systemctl stop wpa_supplicant@{{ network.wifi.client_interface }}; systemctl unmask NetworkManager; systemctl list-unit-files systemd-resolved.service >/dev/null 2>&1 && systemctl unmask systemd-resolved || true; systemctl start NetworkManager; echo "Rollback complete - NetworkManager restored"; fi'

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/nm-transition.service
        mode: '0644'

    - name: Enable NetworkManager transition service
      ansible.builtin.systemd:
        name: nm-transition
        enabled: yes
        daemon_reload: yes

    - name: Create recovery instructions file
      ansible.builtin.copy:
        content: |
          # NetworkManager Transition Recovery Instructions

          If the Raspberry Pi did not successfully transition to dhcpcd:

          ## 1. Check Transition Service Status

          Connect via physical console (monitor + keyboard) and check:

          ```bash
          sudo journalctl -u nm-transition.service -n 50
          ```

          ## 2. Check wpa_supplicant Status

          ```bash
          sudo systemctl status wpa_supplicant@{{ network.wifi.client_interface }}
          sudo journalctl -u wpa_supplicant@{{ network.wifi.client_interface }} -n 50
          ```

          ## 3. Check dhcpcd Status

          ```bash
          sudo systemctl status dhcpcd
          sudo journalctl -u dhcpcd -n 50
          ```

          ## 4. Check WiFi Interface

          ```bash
          ip addr show {{ network.wifi.client_interface }}
          iw {{ network.wifi.client_interface }} link
          ```

          ## ROLLBACK TO NETWORKMANAGER

          If you need to rollback:

          ```bash
          sudo systemctl stop dhcpcd
          sudo systemctl stop wpa_supplicant@{{ network.wifi.client_interface }}
          sudo systemctl unmask NetworkManager
          # Only unmask/start systemd-resolved if it exists on your system
          systemctl list-unit-files systemd-resolved.service >/dev/null 2>&1 && sudo systemctl unmask systemd-resolved || true
          sudo systemctl start NetworkManager
          systemctl list-unit-files systemd-resolved.service >/dev/null 2>&1 && sudo systemctl start systemd-resolved || true
          sudo reboot
          ```

          ## MANUAL FIX (if credentials were wrong)

          Edit WiFi credentials:

          ```bash
          sudo nano /etc/wpa_supplicant/wpa_supplicant-{{ network.wifi.client_interface }}.conf
          ```

          Restart services:

          ```bash
          sudo systemctl restart wpa_supplicant@{{ network.wifi.client_interface }}
          sudo systemctl restart dhcpcd
          ```

          ## GET HELP

          Check system logs:

          ```bash
          sudo journalctl -xe
          ```

          Check network interfaces:

          ```bash
          ip link
          networkctl status
          ```
        dest: "/root/NETWORKMANAGER-TRANSITION-RECOVERY.md"
        mode: '0644'

    - name: Display transition instructions
      ansible.builtin.debug:
        msg: |
          ========================================
          NETWORKMANAGER TRANSITION STAGED
          ========================================

          Configuration has been staged for network manager transition.

          NEXT STEPS:
          1. Reboot the Raspberry Pi:
             sudo reboot

          2. Wait 60 seconds for the Pi to reboot and reconnect to WiFi

          3. Reconnect via SSH (same IP/hostname should work)

          4. Run this playbook again to complete the WiFi AP setup:
             ansible-playbook -i inventory/hosts.yml playbooks/site.yml --vault-password-file .vault_pass

          The transition from NetworkManager to dhcpcd will happen
          automatically during the reboot.
          ========================================

    - name: End playbook after staging NetworkManager transition
      ansible.builtin.meta: end_play
  rescue:
    - name: RESCUE - Inform about NetworkManager transition failure
      ansible.builtin.debug:
        msg: |
          ========================================
          NETWORKMANAGER TRANSITION FAILED!
          ========================================
          An error occurred during the NetworkManager transition block.
          Attempting to rollback to NetworkManager to restore connectivity.
          ========================================
    - name: RESCUE - Ensure NetworkManager is unmasked and started
      ansible.builtin.systemd:
        name: NetworkManager
        masked: no
        state: started
        enabled: yes
        daemon_reload: yes
      ignore_errors: yes
    - name: RESCUE - Ensure systemd-resolved is unmasked and started (if applicable)
      ansible.builtin.systemd:
        name: systemd-resolved
        masked: no
        state: started
        enabled: yes
        daemon_reload: yes
      ignore_errors: yes
      when: systemd_resolved_exists | default(false) | bool
    - name: RESCUE - Fail the play after rollback attempt
      ansible.builtin.fail:
        msg: "NetworkManager transition failed. Attempted rollback to restore connectivity. Please investigate logs."


- name: Check for internet connectivity
  ansible.builtin.shell: ping -c 1 8.8.8.8
  register: internet_connection
  failed_when: false
  changed_when: false
  tags: always  # Always run to ensure variable is defined

- name: Temporarily stop AP interface ensure timer during deployment
  ansible.builtin.systemd:
    name: frey-ensure-ap-interface.timer
    state: stopped
  when: network.wifi.virtual_ap.enabled | default(false)
  failed_when: false
  register: timer_stopped

- name: Temporarily stop AP interface ensure service during deployment
  ansible.builtin.systemd:
    name: frey-ensure-ap-interface.service
    state: stopped
  when: network.wifi.virtual_ap.enabled | default(false)
  failed_when: false
  register: service_stopped

- name: Install packages required for AP
  ansible.builtin.apt:
    name: "{{ wifi_ap_packages | default(['hostapd','dnsmasq','rfkill','iw','dhcpcd5','wpasupplicant','dialog']) }}"
    state: present
    update_cache: yes
  when: internet_connection.rc == 0

- name: Detect 5GHz (802.11a/n) support on AP interface
  ansible.builtin.shell: |
    iw list 2>/dev/null | awk '/Band 2/ {print "5GHZ"; exit}'
  register: wifi_band2_check
  changed_when: false
  failed_when: false

- name: Set effective WiFi band and mode facts
  ansible.builtin.set_fact:
    wifi_5ghz_supported: "{{ wifi_band2_check.stdout | trim == '5GHZ' }}"
    wifi_hw_mode_effective: "{{ (network.wifi.hw_mode | default('g')) if (network.wifi.hw_mode is defined and network.wifi.hw_mode not in ['auto','AUTO']) else ((wifi_band2_check.stdout | trim == '5GHZ') | ternary('a','g')) }}"

- name: Set effective WiFi channel fact
  ansible.builtin.set_fact:
    wifi_channel_effective: >-
      {{
        (
          (36) if (wifi_hw_mode_effective == 'a' and (
            (network.wifi.channel is not defined) or
            ((network.wifi.channel | int) not in [36,40,44,48,149,153,157,161])
          ))
          else (
            (network.wifi.channel | int) if (wifi_hw_mode_effective == 'a') else
            (
              (network.wifi.channel | int) if (
                (network.wifi.channel is defined) and
                ((network.wifi.channel | int) >= 1) and
                ((network.wifi.channel | int) <= 11)
              ) else (7)
            )
          )
        )
      }}

- name: Report WiFi band capability and chosen settings
  ansible.builtin.debug:
    msg: |
      5GHz supported: {{ wifi_5ghz_supported | bool }}
      Requested hw_mode: {{ network.wifi.hw_mode | default('auto') }}
      Effective hw_mode: {{ wifi_hw_mode_effective }}
      Effective channel: {{ wifi_channel_effective }}

- name: Pre-flight AP deployment safety checks
  block:
    - name: Verify AP interface exists and is distinct from control interface
      ansible.builtin.assert:
        that:
          - network.wifi.interface != ansible_default_ipv4.interface
          - network.wifi.interface != (network.wifi.client_interface | default(''))
        msg: |
          ERROR: AP interface conflicts with control or client interface!
          AP interface: {{ network.wifi.interface }}
          Control interface: {{ ansible_default_ipv4.interface }}
          Client interface: {{ network.wifi.client_interface | default('not set') }}

    - name: Check if AP is currently serving clients
      ansible.builtin.shell: |
        if systemctl is-active hostapd >/dev/null 2>&1; then
          hostapd_cli -i {{ network.wifi.interface }} all_sta 2>/dev/null | grep -c "^[0-9a-f]" || echo "0"
        else
          echo "0"
        fi
      register: connected_clients
      changed_when: false
      failed_when: false

    - name: Warn if clients will be disrupted
      ansible.builtin.debug:
        msg: |
          WARNING: {{ connected_clients.stdout }} clients currently connected to AP.
          Deployment will briefly disrupt their connections.
          Set 'skip_ap_deployment: true' in extra-vars to skip WiFi AP role.
      when: (connected_clients.stdout | int) > 0

    - name: Abort if requested to skip AP during active use
      ansible.builtin.meta: end_host
      when:
        - (connected_clients.stdout | int) > 0
        - skip_ap_deployment | default(false)

- name: Determine if wpa_supplicant should be stopped
  ansible.builtin.set_fact:
    wifi_disable_wpasupplicant: "{{ (network.wifi.client_interface is not defined) or (network.wifi.client_interface == network.wifi.interface) }}"

- name: Build list of conflicting services
  ansible.builtin.set_fact:
    wifi_conflicting_services: >-
      {{
        ['systemd-resolved', 'NetworkManager', 'dialog']
        + (wifi_disable_wpasupplicant | ternary(['wpa_supplicant'], []))
      }}

- name: Check which conflicting services exist
  ansible.builtin.systemd:
    name: "{{ item }}"
  loop: "{{ wifi_conflicting_services }}"
  register: service_check
  failed_when: false
  changed_when: false
  loop_control:
    label: "{{ item }}"

- name: Stop and disable conflicting services (best-effort)
  ansible.builtin.systemd:
    name: "{{ item.item }}"
    state: stopped
    enabled: no
    masked: yes
  loop: "{{ service_check.results }}"
  loop_control:
    label: "{{ item.item }}"
  when:
    - not (nm_transition_required | default(false))
    - item.status is defined
    - item.status.LoadState == "loaded"
  ignore_errors: yes

- name: Skip dhcpcd deployment (already staged during NetworkManager transition)
  ansible.builtin.debug:
    msg: "Skipping dhcpcd deployment - already configured during NetworkManager transition staging"
  when: nm_transition_required | default(false)

- name: Deploy dhcpcd configuration for the AP
  ansible.builtin.template:
    src: dhcpcd.conf.j2
    dest: /etc/dhcpcd.conf
    mode: '0644'
    backup: yes
  when: not (nm_transition_required | default(false))
  register: dhcpcd_config_result

- name: Detect if SSH is over interface managed by dhcpcd
  ansible.builtin.set_fact:
    ssh_over_dhcpcd: "{{ ansible_default_ipv4.interface in [network.wifi.client_interface | default('wlan0'), network.wifi.interface] }}"
  when:
    - not (nm_transition_required | default(false))
    - dhcpcd_config_result is changed

- name: Warn about potential SSH disruption
  ansible.builtin.debug:
    msg: |
      WARNING: dhcpcd reload may briefly affect network connection!
      SSH is connected via: {{ ansible_default_ipv4.interface }}
      dhcpcd manages: {{ network.wifi.client_interface | default('wlan0') }}, {{ network.wifi.interface }}

      Using graceful reload with connection preservation...
  when:
    - not (nm_transition_required | default(false))
    - dhcpcd_config_result is changed
    - ssh_over_dhcpcd | default(false)

- name: Reload dhcpcd gracefully (preserve active connections)
  when:
    - not (nm_transition_required | default(false))
    - dhcpcd_config_result is changed
  block:
    - name: Send SIGHUP to dhcpcd (reload config without dropping leases)
      ansible.builtin.command: killall -HUP dhcpcd
      register: dhcpcd_reload
      failed_when: false
      changed_when: dhcpcd_reload.rc == 0

    - name: Wait for dhcpcd to reload (15 seconds for SSH stability)
      ansible.builtin.pause:
        seconds: 15
      when: dhcpcd_reload.rc == 0

  rescue:
    - name: Fallback to full restart if SIGHUP failed
      ansible.builtin.systemd:
        name: dhcpcd
        state: restarted
        enabled: yes
        daemon_reload: yes

    - name: Wait for network to stabilize
      ansible.builtin.pause:
        seconds: 10

- name: Ensure dhcpcd is running if config unchanged
  when:
    - not (nm_transition_required | default(false))
    - dhcpcd_config_result is not changed
  ansible.builtin.systemd:
    name: dhcpcd
    state: started
    enabled: yes

# ==============================================================================
# SSH SERVICE NETWORK DEPENDENCIES
# ==============================================================================
# Ensure SSH starts AFTER network is ready (prevents boot-time inaccessibility)
# This integrates the manual fix from /etc/systemd/system/ssh.service.d/

- name: Create SSH service override directory
  ansible.builtin.file:
    path: /etc/systemd/system/ssh.service.d
    state: directory
    mode: '0755'
  tags:
    - ssh_safety
    - wifi_ap

- name: Deploy SSH network-wait override
  ansible.builtin.template:
    src: ssh-network-wait.conf.j2
    dest: /etc/systemd/system/ssh.service.d/network-wait.conf
    mode: '0644'
  notify: reload systemd
  tags:
    - ssh_safety
    - wifi_ap

- name: Ensure SSH service is enabled
  ansible.builtin.systemd:
    name: ssh
    enabled: yes
    daemon_reload: yes
  tags:
    - ssh_safety
    - wifi_ap

- name: Wait for AP IP to be present on the host
  ansible.builtin.wait_for:
    host: "{{ network.wifi.ip }}"
    timeout: 20

- name: Unblock all WiFi devices via rfkill (Critical for AP startup)
  ansible.builtin.command:
    cmd: rfkill unblock wifi
  changed_when: true
  failed_when: false

- name: Bring up WiFi AP interface unconditionally
  ansible.builtin.command:
    cmd: ip link set {{ network.wifi.interface }} up
  changed_when: true
  failed_when: false

- name: Assemble WiFi interfaces that require power-save disabling
  ansible.builtin.set_fact:
    wifi_power_save_interfaces: >-
      {{
        (
          [
            network.wifi.interface | default(''),
            network.wifi.client_interface | default(''),
            (network.wifi.roaming.client_interface if (network.wifi.roaming is defined and network.wifi.roaming.client_interface is defined) else '')
          ]
          + (network.wifi.power_management.extra_interfaces | default([]))
        )
        | select('truthy')
        | unique
        | list
      }}
  when: network.wifi.power_management.disable_power_save | default(true)

- name: Deploy WiFi power-save disable script
  ansible.builtin.template:
    src: frey-disable-wifi-power-save.sh.j2
    dest: /usr/local/bin/frey-disable-wifi-power-save
    mode: '0755'
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.power_management.disable_power_save | default(true)

- name: Deploy WiFi power-save disable service
  ansible.builtin.template:
    src: frey-disable-wifi-power-save.service.j2
    dest: /etc/systemd/system/frey-disable-wifi-power-save.service
    mode: '0644'
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.power_management.disable_power_save | default(true)

- name: Enable WiFi power-save disable service
  ansible.builtin.systemd:
    name: frey-disable-wifi-power-save
    enabled: yes
    state: started
    daemon_reload: yes
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.power_management.disable_power_save | default(true)

- name: Deploy AP interface ensure script
  ansible.builtin.template:
    src: frey-ensure-ap-interface.sh.j2
    dest: /usr/local/bin/frey-ensure-ap-interface
    mode: '0755'
  when: network.wifi.virtual_ap.enabled | default(false)

- name: Deploy AP interface ensure service
  ansible.builtin.template:
    src: frey-ensure-ap-interface.service.j2
    dest: /etc/systemd/system/frey-ensure-ap-interface.service
  when: network.wifi.virtual_ap.enabled | default(false)

- name: Deploy AP interface ensure timer
  ansible.builtin.template:
    src: frey-ensure-ap-interface.timer.j2
    dest: /etc/systemd/system/frey-ensure-ap-interface.timer
  when: network.wifi.virtual_ap.enabled | default(false)

- name: Ensure AP interface watcher enabled
  ansible.builtin.systemd:
    name: "{{ item }}"
    enabled: true
    state: started
    daemon_reload: true
  loop:
    - frey-ensure-ap-interface.service
    - frey-ensure-ap-interface.timer
  when: network.wifi.virtual_ap.enabled | default(false)

- name: Ensure hostapd override directory exists
  ansible.builtin.file:
    path: /etc/systemd/system/hostapd.service.d
    state: directory
    mode: '0755'

- name: Install hostapd override for AP interface ensure (virtual AP mode)
  ansible.builtin.template:
    src: hostapd-override.conf.j2
    dest: /etc/systemd/system/hostapd.service.d/override-ensure-ap.conf
  when: network.wifi.virtual_ap.enabled | default(false)
  notify: Reload systemd

- name: Install hostapd resilience override (physical adapter mode with hot-plug)
  ansible.builtin.template:
    src: hostapd-override-resilient.conf.j2
    dest: /etc/systemd/system/hostapd.service.d/resilient.conf
    mode: '0644'
  when: not (network.wifi.virtual_ap.enabled | default(false))
  notify: Reload systemd

- name: Ensure AP interface exists before hostapd actions
  ansible.builtin.command:
    cmd: /usr/local/bin/frey-ensure-ap-interface
  changed_when: false
  failed_when: false
  when: network.wifi.virtual_ap.enabled | default(false)

- name: Deploy hostapd configuration
  ansible.builtin.template:
    src: hostapd.conf.j2
    dest: /etc/hostapd/hostapd.conf
    mode: '0644'
  register: hostapd_config_result

- name: Ensure hostapd points at the service config
  ansible.builtin.lineinfile:
    path: /etc/default/hostapd
    regexp: '^#?DAEMON_CONF='
    line: 'DAEMON_CONF="/etc/hostapd/hostapd.conf"'

- name: Unmask hostapd service (required on fresh Raspberry Pi OS)
  ansible.builtin.systemd:
    name: hostapd
    masked: no

- name: Start or reconfigure hostapd with proper state checking
  block:
    - name: Check current hostapd service state
      ansible.builtin.systemd:
        name: hostapd
      register: hostapd_status
      failed_when: false

    - name: Check if hostapd control interface exists
      ansible.builtin.stat:
        path: "/var/run/hostapd/{{ network.wifi.interface }}"
      register: hostapd_control_socket
      when:
        - hostapd_status.status is defined
        - hostapd_status.status.ActiveState == "active"
        - hostapd_config_result is changed

    - name: Try graceful reconfigure if hostapd is active and config changed
      ansible.builtin.command:
        cmd: hostapd_cli -i {{ network.wifi.interface }} reconfigure
      register: hostapd_reconf
      changed_when: hostapd_reconf.rc == 0
      failed_when: false
      when:
        - hostapd_status.status is defined
        - hostapd_status.status.ActiveState == "active"
        - hostapd_config_result is changed
        - hostapd_control_socket.stat.exists | default(false)

    - name: Restart hostapd if reconfigure failed on active service
      ansible.builtin.systemd:
        name: hostapd
        state: restarted
        enabled: yes
        daemon_reload: yes
      when:
        - hostapd_status.status is defined
        - hostapd_status.status.ActiveState == "active"
        - hostapd_config_result is changed
        - hostapd_reconf is defined
        - (hostapd_reconf.rc | default(1)) != 0
        - hostapd_control_socket.stat.exists | default(false)

    - name: Start hostapd if not currently running
      ansible.builtin.systemd:
        name: hostapd
        state: started
        enabled: yes
        daemon_reload: yes
      when:
        - hostapd_status.status is not defined or hostapd_status.status.ActiveState != "active"

    - name: Wait for hostapd to initialize wireless radio
      ansible.builtin.pause:
        seconds: 10

    - name: Verify hostapd is active
      ansible.builtin.systemd:
        name: hostapd
      register: hostapd_verify
      failed_when: hostapd_verify.status.ActiveState != "active"
      retries: 10
      delay: 5
      until: hostapd_verify.status.ActiveState == "active"

  rescue:
    - name: Capture hostapd logs on failure
      ansible.builtin.command:
        cmd: journalctl -u hostapd -n 50 --no-pager
      register: hostapd_logs
      changed_when: false

    - name: Display hostapd failure diagnostics
      ansible.builtin.debug:
        msg: |
          HOSTAPD FAILED TO START
          Interface: {{ network.wifi.interface }}
          Logs: {{ hostapd_logs.stdout_lines }}

    - name: Fail deployment with diagnostic information
      ansible.builtin.fail:
        msg: "hostapd failed to start - see logs above"

# ==============================================================================
# AP Power Save Disable (Stability Fix)
# ==============================================================================
# Disables power saving on the AP interface to prevent client disconnections

- name: Create AP interface power save disable script
  ansible.builtin.copy:
    dest: /usr/local/bin/frey-ap-disable-power-save
    content: |
      #!/bin/bash
      # Disable power management on AP interface to prevent disconnections
      iw dev {{ network.wifi.interface }} set power_save off 2>/dev/null || true
      iwconfig {{ network.wifi.interface }} power off 2>/dev/null || true
    owner: root
    group: root
    mode: '0755'
  tags:
    - wifi_ap

- name: Create systemd service to disable AP power saving
  ansible.builtin.copy:
    dest: /etc/systemd/system/frey-ap-power-save-disable.service
    content: |
      [Unit]
      Description=Disable power saving on FreyHub AP interface
      After=hostapd.service
      BindsTo=hostapd.service

      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/frey-ap-disable-power-save
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target
    owner: root
    group: root
    mode: '0644'
  notify: reload systemd
  tags:
    - wifi_ap

- name: Enable and start AP power save disable service
  ansible.builtin.systemd:
    name: frey-ap-power-save-disable.service
    enabled: yes
    state: started
    daemon_reload: yes
  tags:
    - wifi_ap

# ==============================================================================
# DNS and DHCP Configuration (dnsmasq)
# ==============================================================================

- name: Backup and disable main dnsmasq.conf to prevent conflicts
  ansible.builtin.copy:
    content: |
      # Main dnsmasq.conf disabled by Ansible wifi_access_point role
      # All configuration is in /etc/dnsmasq.d/01-wifi-ap.conf
      # This prevents conflicts with the WiFi AP DHCP/DNS configuration

      # Read configuration from /etc/dnsmasq.d/ directory
      conf-dir=/etc/dnsmasq.d/,.dpkg-dist,.dpkg-old,.dpkg-new
    dest: /etc/dnsmasq.conf
    backup: yes
    mode: '0644'

- name: Ensure dnsmasq directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /var/run/dnsmasq
    - /var/lib/misc
    - /etc/dnsmasq.d

- name: Ensure dnsmasq leases file exists
  ansible.builtin.file:
    path: /var/lib/misc/dnsmasq.leases
    state: touch
    mode: '0644'

- name: Deploy dnsmasq config snippet for AP
  ansible.builtin.template:
    src: dnsmasq.conf.j2
    dest: /etc/dnsmasq.d/01-wifi-ap.conf
    mode: '0644'
  register: dnsmasq_config_result

- name: Create dnsmasq systemd override directory
  ansible.builtin.file:
    path: /etc/systemd/system/dnsmasq.service.d
    state: directory
    mode: '0755'

- name: Deploy dnsmasq systemd override (fix race condition)
  ansible.builtin.template:
    src: dnsmasq-override.conf.j2
    dest: /etc/systemd/system/dnsmasq.service.d/override.conf
    mode: '0644'

- name: Warn about NAT configuration
  ansible.builtin.debug:
    msg: |
      NAT is enabled (network.wifi.enable_nat: {{ network.wifi.enable_nat | default(false) }})
      This will configure iptables MASQUERADE for internet passthrough.
      WiFi AP clients will get internet access via {{ network.wifi.client_interface }}.
  when: network.wifi.enable_nat | default(false)

- name: Deploy Frey NAT Manager script
  ansible.builtin.template:
    src: frey-nat-manager.sh.j2
    dest: /usr/local/bin/frey-nat-manager.sh
    mode: '0755'
  when: network.wifi.enable_nat | default(false)

- name: Deploy Frey NAT Daemon service
  ansible.builtin.template:
    src: frey-natd.service.j2
    dest: /etc/systemd/system/frey-natd.service
    mode: '0644'
  when: network.wifi.enable_nat | default(false)

- name: Reload systemd daemon
  ansible.builtin.systemd:
    daemon_reload: yes

- name: Unmask dnsmasq service (required on fresh Raspberry Pi OS)
  ansible.builtin.systemd:
    name: dnsmasq
    masked: no

- name: Test dnsmasq configuration
  ansible.builtin.command: dnsmasq --test
  register: dnsmasq_test
  changed_when: false
  failed_when: dnsmasq_test.rc != 0

- name: Restart dnsmasq only if configuration changed
  ansible.builtin.systemd:
    name: dnsmasq
    state: restarted
    enabled: yes
    daemon_reload: yes
  when:
    - dnsmasq_test.rc == 0
    - dnsmasq_config_result is changed

- name: Ensure dnsmasq is running if config unchanged
  ansible.builtin.systemd:
    name: dnsmasq
    state: started
    enabled: yes
  when:
    - dnsmasq_test.rc == 0
    - dnsmasq_config_result is not changed

- name: Enable and start Frey NAT Daemon service
  ansible.builtin.systemd:
    name: frey-natd
    state: started
    enabled: yes
    daemon_reload: yes
  when: network.wifi.enable_nat | default(false)

- name: Stop and disable Frey NAT Daemon when NAT disabled
  ansible.builtin.systemd:
    name: frey-natd
    state: stopped
    enabled: no
  when: not (network.wifi.enable_nat | default(false))
  failed_when: false

- name: Wait for dnsmasq to bind on port 53 (DNS) with retry
  ansible.builtin.wait_for:
    host: "{{ network.wifi.ip }}"
    port: 53
    timeout: 30
  retries: 3
  delay: 5
  register: dnsmasq_port_check
  until: dnsmasq_port_check is succeeded

- name: Verify dnsmasq is listening on DHCP port 67 with retry
  ansible.builtin.shell: ss -ulnp | grep ':67' || echo "DHCP_NOT_LISTENING"
  register: dhcp_check
  changed_when: false
  failed_when: "'DHCP_NOT_LISTENING' in dhcp_check.stdout"
  retries: 3
  delay: 2
  until: "'DHCP_NOT_LISTENING' not in dhcp_check.stdout"

- name: Display dnsmasq listening ports
  ansible.builtin.shell: ss -ulnp | grep dnsmasq
  register: dnsmasq_ports
  changed_when: false

- name: Show dnsmasq listening status
  ansible.builtin.debug:
    msg: |
      dnsmasq is listening on:
      {{ dnsmasq_ports.stdout_lines | join('\n') }}

- name: Comprehensive AP deployment validation
  block:
    - name: Wait for AP to fully initialize
      ansible.builtin.pause:
        seconds: 5

    - name: Check hostapd service status
      ansible.builtin.systemd:
        name: hostapd
      register: final_hostapd_check
      failed_when: final_hostapd_check.status.ActiveState != "active"

    - name: Check dnsmasq service status
      ansible.builtin.systemd:
        name: dnsmasq
      register: final_dnsmasq_check
      failed_when: final_dnsmasq_check.status.ActiveState != "active"

    - name: Verify AP is broadcasting
      ansible.builtin.shell: |
        iw dev {{ network.wifi.interface }} info | grep -q "type AP" && echo "BROADCASTING" || echo "NOT_BROADCASTING"
      register: ap_broadcast_check
      changed_when: false
      failed_when: "'NOT_BROADCASTING' in ap_broadcast_check.stdout"

    - name: Verify DHCP is operational
      ansible.builtin.shell: |
        ss -ulnp | grep -q ':67.*dnsmasq' && echo "DHCP_OK" || echo "DHCP_FAILED"
      register: dhcp_operational_check
      changed_when: false
      failed_when: "'DHCP_FAILED' in dhcp_operational_check.stdout"

    - name: Display successful deployment summary
      ansible.builtin.debug:
        msg: |
          ============================================
          WiFi AP DEPLOYMENT SUCCESSFUL
          ============================================
          SSID: {{ network.wifi.ssid }}
          Interface: {{ network.wifi.interface }} ({{ network.wifi.ip }})
          Hostapd: {{ final_hostapd_check.status.ActiveState }}
          dnsmasq: {{ final_dnsmasq_check.status.ActiveState }}
          Broadcasting: {{ 'YES' if 'BROADCASTING' in ap_broadcast_check.stdout else 'NO' }}
          DHCP: {{ 'OPERATIONAL' if 'DHCP_OK' in dhcp_operational_check.stdout else 'FAILED' }}
          ============================================

  rescue:
    - name: DEPLOYMENT FAILED - Initiating Rollback
      ansible.builtin.debug:
        msg: |
          ============================================
          WiFi AP DEPLOYMENT FAILED - ROLLING BACK
          ============================================

    - name: Capture diagnostic logs before rollback
      ansible.builtin.shell: |
        echo "=== hostapd status ==="
        systemctl status hostapd --no-pager -l || true
        echo "=== dnsmasq status ==="
        systemctl status dnsmasq --no-pager -l || true
        echo "=== interface state ==="
        ip addr show {{ network.wifi.interface }} || true
        echo "=== hostapd logs ==="
        journalctl -u hostapd -n 30 --no-pager || true
        echo "=== dnsmasq logs ==="
        journalctl -u dnsmasq -n 30 --no-pager || true
      register: ap_failure_diagnostics
      changed_when: false

    - name: Stop failed services
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - hostapd
        - dnsmasq
        - frey-nat-manager
      ignore_errors: yes

    - name: Restore backup configurations if they exist
      ansible.builtin.shell: |
        # Restore dhcpcd.conf backup
        if [ -f /etc/dhcpcd.conf.backup ]; then
          cp /etc/dhcpcd.conf.backup /etc/dhcpcd.conf
          echo "Restored dhcpcd.conf"
        fi

        # Restore hostapd.conf backup
        if [ -f /etc/hostapd/hostapd.conf.backup ]; then
          cp /etc/hostapd/hostapd.conf.backup /etc/hostapd/hostapd.conf
          echo "Restored hostapd.conf"
        fi

        # Restore dnsmasq backup
        if [ -f /etc/dnsmasq.d/01-wifi-ap.conf.backup ]; then
          cp /etc/dnsmasq.d/01-wifi-ap.conf.backup /etc/dnsmasq.d/01-wifi-ap.conf
          echo "Restored dnsmasq.conf"
        fi
      ignore_errors: yes
      register: rollback_restore

    - name: Restart dhcpcd with original config
      ansible.builtin.systemd:
        name: dhcpcd
        state: restarted
      ignore_errors: yes

    - name: Display failure diagnostics and recovery instructions
      ansible.builtin.debug:
        msg: |
          {{ ap_failure_diagnostics.stdout_lines }}

          ============================================
          ROLLBACK COMPLETE
          ============================================
          Services stopped, configurations restored.

          Recovery steps:
          1. SSH into the Pi (should still work)
          2. Review logs: sudo journalctl -u hostapd -u dnsmasq -f
          3. Check interface: ip addr show {{ network.wifi.interface }}
          4. Fix configuration in group_vars/all/main.yml
          5. Rerun playbook with --tags wifi_access_point

    - name: Fail deployment with rollback notice
      ansible.builtin.fail:
        msg: "WiFi AP deployment FAILED. Services stopped and configs restored. See diagnostics above."

- name: Read DHCP leases (best-effort)
  ansible.builtin.command: cat /var/lib/misc/dnsmasq.leases
  register: dhcp_leases
  changed_when: false
  failed_when: false

- name: Ensure /usr/local/lib/frey directory exists
  ansible.builtin.file:
    path: /usr/local/lib/frey
    state: directory
    mode: '0755'

- name: Deploy Frey WiFi shared library
  ansible.builtin.template:
    src: frey-wifi-lib.sh.j2
    dest: /usr/local/lib/frey/frey-wifi-lib.sh
    mode: '0644'
  tags: [wifi_library]

- name: Deploy main Frey command dispatcher
  ansible.builtin.template:
    src: frey.sh.j2
    dest: /usr/local/bin/frey
    mode: '0755'
  tags: [frey_cli]

- name: Deploy Frey category command handlers
  ansible.builtin.template:
    src: "{{ item }}.j2"
    dest: "/usr/local/lib/frey/{{ item }}"
    mode: '0755'
  loop:
    - wifi-commands.sh
    - ap-commands.sh
    - net-commands.sh
  tags: [frey_cli]

- name: Deploy WiFi connection helper script
  ansible.builtin.template:
    src: frey-connect-wifi.sh.j2
    dest: /usr/local/bin/frey-connect-wifi
    mode: '0755'

- name: Deploy WiFi disconnection helper script
  ansible.builtin.template:
    src: frey-disconnect-wifi.sh.j2
    dest: /usr/local/bin/frey-disconnect-wifi
    mode: '0755'

- name: Deploy WiFi TUI script
  ansible.builtin.template:
    src: frey-wifi-tui.sh.j2
    dest: /usr/local/bin/frey-wifi-tui
    mode: '0755'

- name: Deploy WiFi list/scan script
  ansible.builtin.template:
    src: frey-wifi-list.sh.j2
    dest: /usr/local/bin/frey-wifi-list
    mode: '0755'
  tags: [frey_cli]

- name: Install frey bash completion
  ansible.builtin.template:
    src: frey-completion.bash.j2
    dest: /etc/bash_completion.d/frey
    owner: root
    group: root
    mode: '0644'
  tags: [frey_cli]

- name: Create sudoers file for passwordless frey commands
  ansible.builtin.template:
    src: frey-sudoers.j2
    dest: /etc/sudoers.d/10-frey-wifi
    owner: root
    group: root
    mode: '0440'
    validate: 'visudo -cf %s'
  tags: [frey_cli, security]

- name: Ensure base directory for WiFi connection guide exists
  ansible.builtin.file:
    path: "{{ storage.base_dir | default('/opt/frey') }}"
    state: directory
    mode: '0755'

- name: Deploy WiFi connection guide
  ansible.builtin.copy:
    src: CONNECT-TO-WIFI.md
    dest: "{{ storage.base_dir | default('/opt/frey') }}/CONNECT-TO-WIFI.md"
    mode: '0644'

- name: Deploy WiFi connectivity healthcheck script
  ansible.builtin.template:
    src: frey-wifi-healthcheck.sh.j2
    dest: /usr/local/bin/frey-wifi-healthcheck
    mode: '0755'
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.connectivity_monitor.enabled | default(false)

- name: Deploy WiFi connectivity healthcheck service
  ansible.builtin.template:
    src: frey-wifi-healthcheck.service.j2
    dest: /etc/systemd/system/frey-wifi-healthcheck.service
    mode: '0644'
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.connectivity_monitor.enabled | default(false)

- name: Deploy WiFi connectivity healthcheck timer
  ansible.builtin.template:
    src: frey-wifi-healthcheck.timer.j2
    dest: /etc/systemd/system/frey-wifi-healthcheck.timer
    mode: '0644'
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.connectivity_monitor.enabled | default(false)

- name: Enable WiFi connectivity watchdog timer
  ansible.builtin.systemd:
    name: frey-wifi-healthcheck.timer
    enabled: yes
    state: started
    daemon_reload: yes
  when:
    - not (nm_transition_required | default(false))
    - network.wifi.connectivity_monitor.enabled | default(false)

# ==============================================================================
# BLOCK DNS-over-HTTPS (DoH) - Force clients to use local DNS
# ==============================================================================
# Modern browsers and OS use DoH by default, bypassing local DNS servers.
# This breaks .frey domain resolution even though clients are configured to use 10.20.0.1 DNS.
# Solution: Block HTTPS (port 443) connections to known DoH providers, forcing clients to use standard DNS.

- name: Block Google DoH servers (8.8.8.8, 8.8.4.4) to force local DNS usage
  community.general.ufw:
    rule: reject
    proto: tcp
    to_ip: "{{ item }}"
    to_port: '443'
    from_ip: "{{ network.wifi.network | default('10.20.0.0/24') }}"
    comment: "WIFI_AP: Block DoH to force local DNS"
  loop:
    - 8.8.8.8
    - 8.8.4.4
  ignore_errors: yes

- name: Block Cloudflare DoH servers (1.1.1.1, 1.0.0.1) to force local DNS usage
  community.general.ufw:
    rule: reject
    proto: tcp
    to_ip: "{{ item }}"
    to_port: '443'
    from_ip: "{{ network.wifi.network | default('10.20.0.0/24') }}"
    comment: "WIFI_AP: Block DoH to force local DNS"
  loop:
    - 1.1.1.1
    - 1.0.0.1
  ignore_errors: yes

- name: Block Quad9 DoH servers (9.9.9.9, 149.112.112.112) to force local DNS usage
  community.general.ufw:
    rule: reject
    proto: tcp
    to_ip: "{{ item }}"
    to_port: '443'
    from_ip: "{{ network.wifi.network | default('10.20.0.0/24') }}"
    comment: "WIFI_AP: Block DoH to force local DNS"
  loop:
    - 9.9.9.9
    - 149.112.112.112
  ignore_errors: yes

- name: Display concise AP status
  ansible.builtin.debug:
    msg: |
      WiFi AP Summary:
      Interface: {{ network.wifi.interface }} ({{ network.wifi.ip }})
      SSID: {{ network.wifi.ssid }}
      Hostapd: {{ 'running' if (ansible_facts.services is defined and ansible_facts.services['hostapd.service'] is defined and ansible_facts.services['hostapd.service'].state == 'running') else 'unknown' }}
      dnsmasq: {{ 'running' if (ansible_facts.services is defined and ansible_facts.services['dnsmasq.service'] is defined and ansible_facts.services['dnsmasq.service'].state == 'running') else 'unknown' }}
      DHCP leases entries: {{ dhcp_leases.stdout_lines | length }}

      WiFi Connection Tools:
      - TUI Manager (easiest): sudo frey-wifi-tui
      - CLI Connect: sudo frey-connect-wifi "WiFiName" "password"
      - CLI Disconnect: sudo frey-disconnect-wifi
      - Documentation: {{ storage.base_dir | default('/opt/frey') }}/CONNECT-TO-WIFI.md

# ==============================================================================
# AUTOMATIC WIFI ROAMING SYSTEM
# WPA_SUPPLICANT SETUP FOR CLIENT INTERFACE (Required for WiFi Roaming)
# ==============================================================================

- name: Debug client interface variable
  ansible.builtin.debug:
    msg: "Client interface: {{ network.wifi.client_interface }}"
  when: network.wifi.roaming.enabled | default(false)

- name: Ensure client interface is up
  ansible.builtin.command:
    cmd: ip link set {{ network.wifi.client_interface }} up
  changed_when: true
  failed_when: false
  when: network.wifi.roaming.enabled | default(false)

- name: Check if client interface exists
  ansible.builtin.command:
    cmd: ip link show {{ network.wifi.client_interface }}
  register: interface_check
  changed_when: false
  failed_when: interface_check.rc != 0
  when: network.wifi.roaming.enabled | default(false)

- name: Deploy wpa_supplicant configuration for client interface
  ansible.builtin.template:
    src: wpa_supplicant-wlan0.conf.j2
    dest: /etc/wpa_supplicant/wpa_supplicant-{{ network.wifi.client_interface }}.conf
    mode: '0600'
  notify: restart wpa_supplicant client
  when:
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0

- name: Deploy wpa_supplicant systemd service for client interface
  ansible.builtin.template:
    src: wpa_supplicant-wlan0.service.j2
    dest: /etc/systemd/system/wpa_supplicant-{{ network.wifi.client_interface }}.service
    mode: '0644'
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0
  notify: Reload systemd

- name: Enable and start wpa_supplicant for client interface
  ansible.builtin.systemd:
    name: wpa_supplicant-{{ network.wifi.client_interface }}
    enabled: yes
    state: started
    daemon_reload: yes
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0
  register: wpa_service_start

- name: Check wpa_supplicant service status
  ansible.builtin.systemd:
    name: wpa_supplicant-{{ network.wifi.client_interface }}
  register: wpa_service_status
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0
  changed_when: false

- name: Debug wpa_supplicant service status
  ansible.builtin.debug:
    msg: "wpa_supplicant service state: {{ wpa_service_status.status.ActiveState }}"
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0

- name: Wait for wpa_supplicant control interface (with fallback)
  block:
    - name: Wait for wpa_supplicant control interface
      ansible.builtin.wait_for:
        path: /var/run/wpa_supplicant/{{ network.wifi.client_interface }}
        timeout: 15
      when: 
        - network.wifi.roaming.enabled | default(false)
        - interface_check.rc == 0

  rescue:
    - name: Check if wpa_supplicant process is running
      ansible.builtin.shell:
        cmd: ps aux | grep wpa_supplicant | grep {{ network.wifi.client_interface }} || echo "NOT_RUNNING"
      register: wpa_process_check
      changed_when: false
      when: network.wifi.roaming.enabled | default(false)

    - name: Show wpa_supplicant process status
      ansible.builtin.debug:
        msg: "wpa_supplicant process status: {{ wpa_process_check.stdout }}"
      when: network.wifi.roaming.enabled | default(false)

    - name: Check wpa_supplicant logs
      ansible.builtin.shell:
        cmd: journalctl -u wpa_supplicant-{{ network.wifi.client_interface }} -n 10 --no-pager || echo "NO_LOGS"
      register: wpa_logs
      changed_when: false
      when: network.wifi.roaming.enabled | default(false)

    - name: Show wpa_supplicant logs
      ansible.builtin.debug:
        msg: "wpa_supplicant logs: {{ wpa_logs.stdout }}"
      when: network.wifi.roaming.enabled | default(false)

    - name: Continue despite wpa_supplicant control interface issue
      ansible.builtin.debug:
        msg: "Continuing despite wpa_supplicant control interface not being ready"
      when: network.wifi.roaming.enabled | default(false)

- name: Test wpa_supplicant connectivity (optional)
  ansible.builtin.command:
    cmd: wpa_cli -i {{ network.wifi.client_interface }} status
  register: wpa_cli_test
  changed_when: false
  failed_when: false  # Don't fail the playbook if this doesn't work
  when: network.wifi.roaming.enabled | default(false)

- name: Debug wpa_cli test result
  ansible.builtin.debug:
    msg: "wpa_cli test result: {{ wpa_cli_test.stdout }}"
  when:
    - network.wifi.roaming.enabled | default(false)
    - wpa_cli_test is defined

# ==============================================================================
# WiFi Roaming Daemon Deployment
# ==============================================================================
# Deploy the intelligent WiFi roaming system that automatically:
# - Scans for and connects to known networks
# - Scores networks by signal strength and priority
# - Detects and handles captive portals
# - Falls back gracefully when no networks available

# ------------------------------------------------------------------------------
# Create Required Directories
# ------------------------------------------------------------------------------

- name: Create /etc/frey configuration directory
  ansible.builtin.file:
    path: /etc/frey
    state: directory
    owner: root
    group: root
    mode: '0755'
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Create /var/lib/frey state directory
  ansible.builtin.file:
    path: /var/lib/frey
    state: directory
    owner: root
    group: root
    mode: '0755'
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

# ------------------------------------------------------------------------------
# Deploy Configuration Files
# ------------------------------------------------------------------------------

- name: Deploy WiFi roaming daemon configuration
  ansible.builtin.template:
    src: wifi-roaming.conf.j2
    dest: /etc/frey/wifi-roaming.conf
    owner: root
    group: root
    mode: '0644'
  when: network.wifi.roaming.enabled | default(false)
  notify: Restart frey-wifid
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy known WiFi networks configuration
  ansible.builtin.template:
    src: known-networks.conf.j2
    dest: /etc/frey/known-networks.conf
    owner: root
    group: root
    mode: '0600'
  when: network.wifi.roaming.enabled | default(false)
  notify: Restart frey-wifid
  no_log: true
  tags:
    - wifi_roaming
    - roaming_daemon

# ------------------------------------------------------------------------------
# Deploy Daemon Scripts
# ------------------------------------------------------------------------------

- name: Deploy WiFi roaming daemon script
  ansible.builtin.copy:
    src: frey-wifi-roaming-daemon.sh
    dest: /usr/local/bin/frey-wifi-roaming-daemon
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi internet verification helper
  ansible.builtin.copy:
    src: frey-wifi-internet-verify.sh
    dest: /usr/local/bin/frey-wifi-internet-verify
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi network scorer helper
  ansible.builtin.copy:
    src: frey-wifi-network-scorer.sh
    dest: /usr/local/bin/frey-wifi-network-scorer
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi captive portal auto-handler
  ansible.builtin.copy:
    src: frey-wifi-captive-portal-auto.sh
    dest: /usr/local/bin/frey-wifi-captive-portal-auto
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi roaming pause/resume control script
  ansible.builtin.copy:
    src: frey-wifi-pause.sh
    dest: /usr/local/bin/frey-wifi-pause
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi roaming daemon systemd service
  ansible.builtin.template:
    src: frey-wifid.service.j2
    dest: /etc/systemd/system/frey-wifid.service
    mode: '0644'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  notify:
    - reload systemd
    - Restart frey-wifid
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Enable and start WiFi roaming daemon
  ansible.builtin.systemd:
    name: frey-wifid
    enabled: yes
    state: started
    daemon_reload: yes
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Check WiFi roaming daemon status
  ansible.builtin.systemd:
    name: frey-wifid
  register: roaming_daemon_status
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Display WiFi roaming daemon status
  ansible.builtin.debug:
    msg: "WiFi roaming daemon is {{ roaming_daemon_status.status.ActiveState }}"
  when:
    - network.wifi.roaming.enabled | default(false)
    - roaming_daemon_status is defined
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Re-enable AP interface ensure timer after deployment
  ansible.builtin.systemd:
    name: "{{ item }}"
    enabled: yes
    state: started
    daemon_reload: yes
  loop:
    - frey-ensure-ap-interface.service
    - frey-ensure-ap-interface.timer
  when:
    - network.wifi.virtual_ap.enabled | default(false)
    - timer_stopped is defined or service_stopped is defined

# ==============================================================================
# WIFI AP HEALTH CHECK SERVICE
# ==============================================================================
# Monitors critical AP services and auto-restarts them if they fail

- name: Deploy WiFi AP health check script
  ansible.builtin.template:
    src: frey-ap-healthcheck.sh.j2
    dest: /usr/local/bin/frey-ap-healthcheck
    mode: '0755'
  tags:
    - wifi_ap
    - health_check

- name: Deploy WiFi AP health check service
  ansible.builtin.copy:
    content: |
      [Unit]
      Description=Frey WiFi AP Health Check
      After=network-online.target hostapd.service dnsmasq.service

      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/frey-ap-healthcheck
    dest: /etc/systemd/system/frey-ap-healthcheck.service
    mode: '0644'
  tags:
    - wifi_ap
    - health_check

- name: Deploy WiFi AP health check timer
  ansible.builtin.copy:
    content: |
      [Unit]
      Description=Frey WiFi AP Health Check Timer

      [Timer]
      OnBootSec=5min
      OnUnitActiveSec=5min

      [Install]
      WantedBy=timers.target
    dest: /etc/systemd/system/frey-ap-healthcheck.timer
    mode: '0644'
  tags:
    - wifi_ap
    - health_check

- name: Enable WiFi AP health check timer
  ansible.builtin.systemd:
    name: frey-ap-healthcheck.timer
    enabled: yes
    state: started
    daemon_reload: yes
  tags:
    - wifi_ap
    - health_check

# ==============================================================================
# WIFI HOT-PLUG SUPPORT (USB WiFi Adapter Detection)
# ==============================================================================
# Automatically start AP services when USB WiFi adapter is plugged in

- name: Deploy WiFi hot-plug udev rule
  ansible.builtin.template:
    src: 80-frey-wifi-hotplug.rules.j2
    dest: /etc/udev/rules.d/80-frey-wifi-hotplug.rules
    mode: '0644'
  when: not (network.wifi.virtual_ap.enabled | default(false))
  notify: Reload udev
  tags:
    - wifi_ap
    - hot_plug

# ==============================================================================
# MDNS HOSTNAME RESOLUTION (Avahi)
# ==============================================================================
# Deploy Avahi daemon for .local hostname resolution across all networks
# Enables seamless SSH access via hostname without knowing IP address
#
# USE CASES:
# - Phone hotspot (dynamic IPs): ssh ansible@frey.local
# - FreyHub WiFi AP: ssh ansible@frey or ssh ansible@10.20.0.1
# - Home WiFi: ssh ansible@frey.local
# - Any network: Works universally, completely offline-capable
#
# PROTOCOL: mDNS (Multicast DNS) / Bonjour / Avahi
# - Broadcasts hostname.local on all active interfaces
# - Zero-configuration discovery (no DNS server needed)
# - Standard protocol supported by all modern devices
# ==============================================================================

- name: Install Avahi packages for mDNS hostname resolution
  ansible.builtin.apt:
    name:
      - avahi-daemon      # mDNS daemon (broadcasts hostname.local)
      - avahi-utils       # Command-line tools (avahi-browse, avahi-resolve)
      - libnss-mdns       # NSS module for .local domain resolution
    state: present
    update_cache: no
  when: internet_connection.rc == 0
  tags:
    - wifi_ap
    - mdns
    - avahi

- name: Deploy Avahi daemon configuration
  ansible.builtin.template:
    src: avahi-daemon.conf.j2
    dest: /etc/avahi/avahi-daemon.conf
    owner: root
    group: root
    mode: '0644'
    backup: yes
  notify: restart avahi
  tags:
    - wifi_ap
    - mdns
    - avahi

- name: Configure nsswitch.conf for mDNS resolution
  ansible.builtin.lineinfile:
    path: /etc/nsswitch.conf
    regexp: '^hosts:'
    line: 'hosts:          files mdns4_minimal [NOTFOUND=return] dns mdns4'
    backup: yes
  notify: restart avahi
  tags:
    - wifi_ap
    - mdns
    - avahi

- name: Enable and start Avahi daemon
  ansible.builtin.systemd:
    name: avahi-daemon
    enabled: yes
    state: started
    daemon_reload: yes
  tags:
    - wifi_ap
    - mdns
    - avahi

- name: Display mDNS hostname information
  ansible.builtin.debug:
    msg: |
      ============================================
      mDNS HOSTNAME RESOLUTION ENABLED
      ============================================
      Hostname: {{ inventory_hostname }}.local

      SSH Access (No IP needed!):
      - ssh {{ users.default.name }}@{{ inventory_hostname }}.local
      - ssh {{ users.default.name }}@{{ inventory_hostname }}  (via search domain)

      Works on:
      - Phone hotspot (any IP)
      - FreyHub WiFi AP (10.20.0.1)
      - Home WiFi (any network)
      - Ethernet (if connected)

      Test:
      - ping {{ inventory_hostname }}.local
      - avahi-browse -a -t  (list all mDNS services)
      ============================================
  tags:
    - wifi_ap
    - mdns
    - avahi

# ==============================================================================
# CAPTIVE PORTAL DEPENDENCIES (PYTHON + SELENIUM)
# ==============================================================================

- name: Install dependencies for Selenium-based captive portal bypass
  tags:
    - wifi_roaming
    - captive_portal
    - packages
  when:
    - network.wifi.roaming.enabled | default(false)
    - internet_connection.rc == 0  # Only attempt if internet is available
  block:
    - name: Install base packages for portal bypass
      ansible.builtin.apt:
        name:
          - python3
          - python3-pip
          - firefox-esr
          - lynx  # Terminal browser for simple accept-button portals
        state: present
        update_cache: yes
        cache_valid_time: 3600  # Only update cache if older than 1 hour
      register: apt_result
      retries: 3
      delay: 5
      until: apt_result is succeeded

    - name: Install Python libraries for Selenium
      ansible.builtin.apt:
        name: python3-selenium
        state: present

    - name: Set geckodriver facts
      ansible.builtin.set_fact:
        geckodriver_version: "v0.36.0"
        arch_map:
          aarch64: "linux-aarch64"
          armv7l: "linux-arm7hf"
          x86_64: "linux64"

    - name: Determine geckodriver architecture for download
      ansible.builtin.set_fact:
        geckodriver_arch: "{{ arch_map[ansible_architecture] | default('linux64') }}"

    - name: Download and unarchive geckodriver
      ansible.builtin.unarchive:
        src: "https://github.com/mozilla/geckodriver/releases/download/{{ geckodriver_version }}/geckodriver-{{ geckodriver_version }}-{{ geckodriver_arch }}.tar.gz"
        dest: /usr/local/bin
        remote_src: yes
        creates: /usr/local/bin/geckodriver
      become: yes

- name: Log portal package installation status
  ansible.builtin.debug:
    msg: >
      Portal packages installation: {{ 'SUCCESS' if (apt_result is defined and apt_result is succeeded) else ('SKIPPED - No internet connection' if internet_connection.rc != 0 else 'SKIPPED (failed)') }}
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal
    - packages

# ==============================================================================
# CAPTIVE PORTAL AUTOMATION DAEMON
# ==============================================================================
# Automatically accepts login pages and verifies internet connectivity
# when connecting to public WiFi networks (library, airport, coffee shops, etc.)
#
# This daemon runs in the background and:
# - Monitors for captive portal detection
# - Automatically submits login forms
# - Verifies internet connectivity
# - Logs activity for debugging

- name: Create captive portal state directory
  ansible.builtin.file:
    path: /var/lib/frey/captive-portal
    state: directory
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Create MOTD directory for portal notifications
  ansible.builtin.file:
    path: /etc/motd.d
    state: directory
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Deploy manual captive portal login tool
  ansible.builtin.copy:
    src: frey-portal-login.sh
    dest: /usr/local/bin/frey-portal-login
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Deploy captive portal shell bypass script (primary method)
  ansible.builtin.copy:
    src: frey-wifi-portal-shell-bypass.sh
    dest: /usr/local/bin/frey-wifi-portal-shell-bypass.sh
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Deploy captive portal bypasser python script (fallback method)
  ansible.builtin.copy:
    src: frey-wifi-portal-bypasser.py
    dest: /usr/local/bin/frey-wifi-portal-bypasser.py
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Deploy captive portal automation helper script
  ansible.builtin.copy:
    src: frey-wifi-captive-portal-auto.sh
    dest: /usr/local/bin/frey-wifi-captive-portal-auto
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Deploy captive portal daemon wrapper script (adaptive intervals)
  ansible.builtin.template:
    src: frey-wifi-captive-portal-daemon.sh.j2
    dest: /usr/local/bin/frey-wifi-captive-portal-daemon
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - captive_portal

- name: Deploy captive portal test script
  ansible.builtin.copy:
    src: test-portal-bypass.sh
    dest: /usr/local/bin/test-portal-bypass
    mode: '0755'
    owner: root
    group: root
  tags:
    - portal_test
    - captive_portal

- name: Deploy portal debug script
  ansible.builtin.copy:
    src: debug-portal.sh
    dest: /usr/local/bin/debug-portal
    mode: '0755'
    owner: root
    group: root
  tags:
    - portal_test
    - captive_portal

- name: Deploy DHCP debug script with auto-reconnect
  ansible.builtin.copy:
    src: dhcp-debug-auto.sh
    dest: /usr/local/bin/dhcp-debug-auto
    mode: '0755'
    owner: root
    group: root
  tags:
    - portal_test
    - captive_portal
    - dhcp_debug

- name: Deploy captive portal daemon service
  ansible.builtin.template:
    src: frey-wifi-captive-portal-daemon.service.j2
    dest: /etc/systemd/system/frey-wifi-captive-portal-daemon.service
    mode: '0644'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  notify: Reload systemd
  tags:
    - wifi_roaming
    - captive_portal

- name: Enable and start captive portal daemon
  ansible.builtin.systemd:
    name: frey-wifi-captive-portal-daemon
    enabled: yes
    state: started
    daemon_reload: yes
  when: network.wifi.roaming.enabled | default(false)
  register: portal_daemon_status
  tags:
    - wifi_roaming
    - captive_portal

- name: Display captive portal daemon status
  ansible.builtin.debug:
    msg: |
      Captive Portal Daemon Status: {{ portal_daemon_status.status.ActiveState if portal_daemon_status.status is defined else 'unknown' }}
      
      Logs:
      - sudo systemctl status frey-wifi-captive-portal-daemon
      - sudo journalctl -u frey-wifi-captive-portal-daemon -f
      
      To run manually for testing:
      - sudo /usr/local/bin/frey-wifi-captive-portal-auto
  when:
    - network.wifi.roaming.enabled | default(false)
    - portal_daemon_status is defined
  tags:
    - wifi_roaming
    - captive_portal
