---
# roles/wifi_access_point/tasks/main.yml
# Final clean single-document tasks for AP bring-up.

- name: Assert required wifi variables are defined
  ansible.builtin.assert:
    that:
      - network.wifi.interface is defined
      - network.wifi.ssid is defined
      - network.wifi.password is defined
      - network.wifi.ip is defined
      - network.wifi.dhcp_range_start is defined
      - network.wifi.dhcp_range_end is defined
    msg: "Required wifi_access_point variables missing. See roles/wifi_access_point/README.md"

- name: Fail if attempting to configure the control interface (avoid disconnecting admin)
  ansible.builtin.fail:
    msg: "Refusing to modify {{ network.wifi.interface }} because it matches the control interface {{ ansible_default_ipv4.interface }}. Set network.wifi.interface to a secondary adapter (e.g. wlan1) or set force_apply=true to override."
  when:
    - (network.wifi.interface == ansible_default_ipv4.interface) and (force_apply | default(false) | bool) == false

- name: Check for internet connectivity
  ansible.builtin.shell: ping -c 1 8.8.8.8
  register: internet_connection
  failed_when: false
  changed_when: false

- name: Install packages required for AP
  ansible.builtin.apt:
    name: "{{ wifi_ap_packages | default(['hostapd','dnsmasq','rfkill','iw','dhcpcd5','wpasupplicant','dialog']) }}"
    state: present
    update_cache: yes
  when: internet_connection.rc == 0

- name: Detect 5GHz (802.11a/n) support on AP interface
  ansible.builtin.shell: |
    iw list 2>/dev/null | awk '/Band 2/ {print "5GHZ"; exit}'
  register: wifi_band2_check
  changed_when: false
  failed_when: false

- name: Set effective WiFi mode/channel facts
  ansible.builtin.set_fact:
    wifi_5ghz_supported: "{{ wifi_band2_check.stdout | trim == '5GHZ' }}"
    wifi_hw_mode_effective: "{{ (network.wifi.hw_mode | default('g')) if (network.wifi.hw_mode is defined and network.wifi.hw_mode not in ['auto','AUTO']) else ((wifi_band2_check.stdout | trim == '5GHZ') | ternary('a','g')) }}"
    wifi_channel_effective: >-
      {{
        (
          (36) if (wifi_hw_mode_effective == 'a' and (
            (network.wifi.channel is not defined) or
            ((network.wifi.channel | int) not in [36,40,44,48,149,153,157,161])
          ))
          else (
            (network.wifi.channel | int) if (wifi_hw_mode_effective == 'a') else
            (
              (network.wifi.channel | int) if (
                (network.wifi.channel is defined) and
                ((network.wifi.channel | int) >= 1) and
                ((network.wifi.channel | int) <= 11)
              ) else (7)
            )
          )
        )
      }}

- name: Report WiFi band capability and chosen settings
  ansible.builtin.debug:
    msg: |
      5GHz supported: {{ wifi_5ghz_supported | bool }}
      Requested hw_mode: {{ network.wifi.hw_mode | default('auto') }}
      Effective hw_mode: {{ wifi_hw_mode_effective }}
      Effective channel: {{ wifi_channel_effective }}

- name: Check which conflicting services exist
  ansible.builtin.systemd:
    name: "{{ item }}"
  loop:
    - systemd-resolved
    - NetworkManager
    - wpa_supplicant
    - dialog
  register: service_check
  failed_when: false
  changed_when: false

- name: Stop and disable conflicting services (best-effort)
  ansible.builtin.systemd:
    name: "{{ item.item }}"
    state: stopped
    enabled: no
    masked: yes
  loop: "{{ service_check.results }}"
  when: item.status is defined and item.status.LoadState == "loaded"
  ignore_errors: yes

- name: Deploy dhcpcd configuration for the AP
  ansible.builtin.template:
    src: dhcpcd.conf.j2
    dest: /etc/dhcpcd.conf
    mode: '0644'
    backup: yes

- name: Restart dhcpcd
  ansible.builtin.systemd:
    name: dhcpcd
    state: restarted
    enabled: yes
    daemon_reload: yes

- name: Wait for AP IP to be present on the host
  ansible.builtin.wait_for:
    host: "{{ network.wifi.ip }}"
    timeout: 20

- name: Unblock all WiFi devices via rfkill (Critical for AP startup)
  ansible.builtin.command:
    cmd: rfkill unblock wifi
  changed_when: true
  failed_when: false

- name: Bring up WiFi AP interface unconditionally
  ansible.builtin.command:
    cmd: ip link set {{ network.wifi.interface }} up
  changed_when: true
  failed_when: false

- name: Deploy hostapd configuration
  ansible.builtin.template:
    src: hostapd.conf.j2
    dest: /etc/hostapd/hostapd.conf
    mode: '0644'

- name: Ensure hostapd points at the service config
  ansible.builtin.lineinfile:
    path: /etc/default/hostapd
    regexp: '^#?DAEMON_CONF='
    line: 'DAEMON_CONF="/etc/hostapd/hostapd.conf"'

- name: Unmask hostapd service (required on fresh Raspberry Pi OS)
  ansible.builtin.systemd:
    name: hostapd
    masked: no

- name: Start hostapd
  block:
    - name: Try to reconfigure hostapd (if already running)
      ansible.builtin.command:
        cmd: hostapd_cli -i {{ network.wifi.interface }} reconfigure
      register: hostapd_reconf
      changed_when: hostapd_reconf.rc == 0
      failed_when: false

    - name: Start hostapd if it was not running or reconfigure failed
      ansible.builtin.systemd:
        name: hostapd
        state: started
        enabled: yes
        daemon_reload: yes
      when: hostapd_reconf is not defined or hostapd_reconf.rc != 0

  rescue:
    - name: Ensure hostapd service is started (rescue)
      ansible.builtin.systemd:
        name: hostapd
        state: started
        enabled: yes
        daemon_reload: yes

- name: Pause briefly to let hostapd initialize
  ansible.builtin.pause:
    seconds: 3

- name: Backup and disable main dnsmasq.conf to prevent conflicts
  ansible.builtin.copy:
    content: |
      # Main dnsmasq.conf disabled by Ansible wifi_access_point role
      # All configuration is in /etc/dnsmasq.d/01-wifi-ap.conf
      # This prevents conflicts with the WiFi AP DHCP/DNS configuration

      # Read configuration from /etc/dnsmasq.d/ directory
      conf-dir=/etc/dnsmasq.d/,.dpkg-dist,.dpkg-old,.dpkg-new
    dest: /etc/dnsmasq.conf
    backup: yes
    mode: '0644'

- name: Ensure dnsmasq directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /var/run/dnsmasq
    - /var/lib/misc
    - /etc/dnsmasq.d

- name: Ensure dnsmasq leases file exists
  ansible.builtin.file:
    path: /var/lib/misc/dnsmasq.leases
    state: touch
    mode: '0644'

- name: Deploy dnsmasq config snippet for AP
  ansible.builtin.template:
    src: dnsmasq.conf.j2
    dest: /etc/dnsmasq.d/01-wifi-ap.conf
    mode: '0644'

- name: Create dnsmasq systemd override directory
  ansible.builtin.file:
    path: /etc/systemd/system/dnsmasq.service.d
    state: directory
    mode: '0755'

- name: Deploy dnsmasq systemd override (fix race condition)
  ansible.builtin.template:
    src: dnsmasq-override.conf.j2
    dest: /etc/systemd/system/dnsmasq.service.d/override.conf
    mode: '0644'

- name: Deploy Frey NAT Manager script
  ansible.builtin.template:
    src: frey-nat-manager.sh.j2
    dest: /usr/local/bin/frey-nat-manager.sh
    mode: '0755'

- name: Deploy Frey NAT Manager service
  ansible.builtin.template:
    src: frey-nat-manager.service.j2
    dest: /etc/systemd/system/frey-nat-manager.service
    mode: '0644'

- name: Reload systemd daemon
  ansible.builtin.systemd:
    daemon_reload: yes

- name: Unmask dnsmasq service (required on fresh Raspberry Pi OS)
  ansible.builtin.systemd:
    name: dnsmasq
    masked: no

- name: Test dnsmasq configuration
  ansible.builtin.command: dnsmasq --test
  register: dnsmasq_test
  changed_when: false
  failed_when: dnsmasq_test.rc != 0

- name: Force restart dnsmasq to apply new configuration
  ansible.builtin.systemd:
    name: dnsmasq
    state: restarted
    enabled: yes
    daemon_reload: yes
  when: dnsmasq_test.rc == 0

- name: Enable and start Frey NAT Manager service
  ansible.builtin.systemd:
    name: frey-nat-manager
    state: started
    enabled: yes
    daemon_reload: yes

- name: Wait for dnsmasq to bind on port 53 (DNS)
  ansible.builtin.wait_for:
    host: "{{ network.wifi.ip }}"
    port: 53
    timeout: 30

- name: Verify dnsmasq is listening on DHCP port 67
  ansible.builtin.shell: ss -ulnp | grep ':67' || echo "DHCP_NOT_LISTENING"
  register: dhcp_check
  changed_when: false
  failed_when: "'DHCP_NOT_LISTENING' in dhcp_check.stdout"

- name: Display dnsmasq listening ports
  ansible.builtin.shell: ss -ulnp | grep dnsmasq
  register: dnsmasq_ports
  changed_when: false

- name: Show dnsmasq listening status
  ansible.builtin.debug:
    msg: |
      dnsmasq is listening on:
      {{ dnsmasq_ports.stdout_lines | join('\n') }}

- name: Read DHCP leases (best-effort)
  ansible.builtin.command: cat /var/lib/misc/dnsmasq.leases
  register: dhcp_leases
  changed_when: false
  failed_when: false

- name: Deploy WiFi connection helper script
  ansible.builtin.template:
    src: frey-connect-wifi.sh.j2
    dest: /usr/local/bin/frey-connect-wifi
    mode: '0755'

- name: Deploy WiFi disconnection helper script
  ansible.builtin.template:
    src: frey-disconnect-wifi.sh.j2
    dest: /usr/local/bin/frey-disconnect-wifi
    mode: '0755'

- name: Deploy WiFi TUI script
  ansible.builtin.template:
    src: frey-wifi-tui.sh.j2
    dest: /usr/local/bin/frey-wifi-tui
    mode: '0755'

- name: Ensure base directory for WiFi connection guide exists
  ansible.builtin.file:
    path: "{{ storage.base_dir | default('/opt/frey') }}"
    state: directory
    mode: '0755'

- name: Deploy WiFi connection guide
  ansible.builtin.copy:
    src: CONNECT-TO-WIFI.md
    dest: "{{ storage.base_dir | default('/opt/frey') }}/CONNECT-TO-WIFI.md"
    mode: '0644'

# ==============================================================================
# BLOCK DNS-over-HTTPS (DoH) - Force clients to use local DNS
# ==============================================================================
# Modern browsers and OS use DoH by default, bypassing local DNS servers.
# This breaks .frey domain resolution even though clients are configured to use 10.20.0.1 DNS.
# Solution: Block HTTPS (port 443) connections to known DoH providers, forcing clients to use standard DNS.

- name: Block Google DoH servers (8.8.8.8, 8.8.4.4) to force local DNS usage
  community.general.ufw:
    rule: reject
    proto: tcp
    to_ip: "{{ item }}"
    to_port: '443'
    from_ip: "{{ network.wifi.network | default('10.20.0.0/24') }}"
    comment: "WIFI_AP: Block DoH to force local DNS"
  loop:
    - 8.8.8.8
    - 8.8.4.4
  ignore_errors: yes

- name: Block Cloudflare DoH servers (1.1.1.1, 1.0.0.1) to force local DNS usage
  community.general.ufw:
    rule: reject
    proto: tcp
    to_ip: "{{ item }}"
    to_port: '443'
    from_ip: "{{ network.wifi.network | default('10.20.0.0/24') }}"
    comment: "WIFI_AP: Block DoH to force local DNS"
  loop:
    - 1.1.1.1
    - 1.0.0.1
  ignore_errors: yes

- name: Block Quad9 DoH servers (9.9.9.9, 149.112.112.112) to force local DNS usage
  community.general.ufw:
    rule: reject
    proto: tcp
    to_ip: "{{ item }}"
    to_port: '443'
    from_ip: "{{ network.wifi.network | default('10.20.0.0/24') }}"
    comment: "WIFI_AP: Block DoH to force local DNS"
  loop:
    - 9.9.9.9
    - 149.112.112.112
  ignore_errors: yes

- name: Display concise AP status
  ansible.builtin.debug:
    msg: |
      WiFi AP Summary:
      Interface: {{ network.wifi.interface }} ({{ network.wifi.ip }})
      SSID: {{ network.wifi.ssid }}
      Hostapd: {{ 'running' if (ansible_facts.services is defined and ansible_facts.services['hostapd.service'] is defined and ansible_facts.services['hostapd.service'].state == 'running') else 'unknown' }}
      dnsmasq: {{ 'running' if (ansible_facts.services is defined and ansible_facts.services['dnsmasq.service'] is defined and ansible_facts.services['dnsmasq.service'].state == 'running') else 'unknown' }}
      DHCP leases entries: {{ dhcp_leases.stdout_lines | length }}

      WiFi Connection Tools:
      - TUI Manager (easiest): sudo frey-wifi-tui
      - CLI Connect: sudo frey-connect-wifi "WiFiName" "password"
      - CLI Disconnect: sudo frey-disconnect-wifi
      - Documentation: {{ storage.base_dir | default('/opt/frey') }}/CONNECT-TO-WIFI.md

# ==============================================================================
# AUTOMATIC WIFI ROAMING SYSTEM
# WPA_SUPPLICANT SETUP FOR CLIENT INTERFACE (Required for WiFi Roaming)
# ==============================================================================

- name: Debug client interface variable
  ansible.builtin.debug:
    msg: "Client interface: {{ network.wifi.client_interface }}"
  when: network.wifi.roaming.enabled | default(false)

- name: Ensure client interface is up
  ansible.builtin.command:
    cmd: ip link set {{ network.wifi.client_interface }} up
  changed_when: true
  failed_when: false
  when: network.wifi.roaming.enabled | default(false)

- name: Check if client interface exists
  ansible.builtin.command:
    cmd: ip link show {{ network.wifi.client_interface }}
  register: interface_check
  changed_when: false
  failed_when: interface_check.rc != 0
  when: network.wifi.roaming.enabled | default(false)

- name: Deploy wpa_supplicant configuration for client interface
  ansible.builtin.template:
    src: wpa_supplicant-wlan0.conf.j2
    dest: /etc/wpa_supplicant/wpa_supplicant-{{ network.wifi.client_interface }}.conf
    mode: '0600'
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0

- name: Deploy wpa_supplicant systemd service for client interface
  ansible.builtin.template:
    src: wpa_supplicant-wlan0.service.j2
    dest: /etc/systemd/system/wpa_supplicant-{{ network.wifi.client_interface }}.service
    mode: '0644'
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0
  notify: Reload systemd

- name: Enable and start wpa_supplicant for client interface
  ansible.builtin.systemd:
    name: wpa_supplicant-{{ network.wifi.client_interface }}
    enabled: yes
    state: started
    daemon_reload: yes
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0
  register: wpa_service_start

- name: Check wpa_supplicant service status
  ansible.builtin.systemd:
    name: wpa_supplicant-{{ network.wifi.client_interface }}
  register: wpa_service_status
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0
  changed_when: false

- name: Debug wpa_supplicant service status
  ansible.builtin.debug:
    msg: "wpa_supplicant service state: {{ wpa_service_status.status.ActiveState }}"
  when: 
    - network.wifi.roaming.enabled | default(false)
    - interface_check.rc == 0

- name: Wait for wpa_supplicant control interface (with fallback)
  block:
    - name: Wait for wpa_supplicant control interface
      ansible.builtin.wait_for:
        path: /var/run/wpa_supplicant/{{ network.wifi.client_interface }}
        timeout: 15
      when: 
        - network.wifi.roaming.enabled | default(false)
        - interface_check.rc == 0

  rescue:
    - name: Check if wpa_supplicant process is running
      ansible.builtin.shell:
        cmd: ps aux | grep wpa_supplicant | grep {{ network.wifi.client_interface }} || echo "NOT_RUNNING"
      register: wpa_process_check
      changed_when: false
      when: network.wifi.roaming.enabled | default(false)

    - name: Show wpa_supplicant process status
      ansible.builtin.debug:
        msg: "wpa_supplicant process status: {{ wpa_process_check.stdout }}"
      when: network.wifi.roaming.enabled | default(false)

    - name: Check wpa_supplicant logs
      ansible.builtin.shell:
        cmd: journalctl -u wpa_supplicant-{{ network.wifi.client_interface }} -n 10 --no-pager || echo "NO_LOGS"
      register: wpa_logs
      changed_when: false
      when: network.wifi.roaming.enabled | default(false)

    - name: Show wpa_supplicant logs
      ansible.builtin.debug:
        msg: "wpa_supplicant logs: {{ wpa_logs.stdout }}"
      when: network.wifi.roaming.enabled | default(false)

    - name: Continue despite wpa_supplicant control interface issue
      ansible.builtin.debug:
        msg: "Continuing despite wpa_supplicant control interface not being ready"
      when: network.wifi.roaming.enabled | default(false)

- name: Test wpa_supplicant connectivity (optional)
  ansible.builtin.command:
    cmd: wpa_cli -i {{ network.wifi.client_interface }} status
  register: wpa_cli_test
  changed_when: false
  failed_when: false  # Don't fail the playbook if this doesn't work
  when: network.wifi.roaming.enabled | default(false)

- name: Debug wpa_cli test result
  ansible.builtin.debug:
    msg: "wpa_cli test result: {{ wpa_cli_test.stdout }}"
  when:
    - network.wifi.roaming.enabled | default(false)
    - wpa_cli_test is defined

# ==============================================================================
# WiFi Roaming Daemon Deployment
# ==============================================================================
# Deploy the intelligent WiFi roaming system that automatically:
# - Scans for and connects to known networks
# - Scores networks by signal strength and priority
# - Detects and handles captive portals
# - Falls back gracefully when no networks available

- name: Deploy WiFi roaming daemon script
  ansible.builtin.copy:
    src: frey-wifi-roaming-daemon.sh
    dest: /usr/local/bin/frey-wifi-roaming-daemon
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi internet verification helper
  ansible.builtin.copy:
    src: frey-wifi-internet-verify.sh
    dest: /usr/local/bin/frey-wifi-internet-verify
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi network scorer helper
  ansible.builtin.copy:
    src: frey-wifi-network-scorer.sh
    dest: /usr/local/bin/frey-wifi-network-scorer
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi captive portal auto-handler
  ansible.builtin.copy:
    src: frey-wifi-captive-portal-auto.sh
    dest: /usr/local/bin/frey-wifi-captive-portal-auto
    mode: '0755'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Deploy WiFi roaming systemd service
  ansible.builtin.template:
    src: frey-wifi-roaming.service.j2
    dest: /etc/systemd/system/frey-wifi-roaming.service
    mode: '0644'
    owner: root
    group: root
  when: network.wifi.roaming.enabled | default(false)
  notify: Reload systemd
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Enable and start WiFi roaming daemon
  ansible.builtin.systemd:
    name: frey-wifi-roaming
    enabled: yes
    state: started
    daemon_reload: yes
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Check WiFi roaming daemon status
  ansible.builtin.systemd:
    name: frey-wifi-roaming
  register: roaming_daemon_status
  when: network.wifi.roaming.enabled | default(false)
  tags:
    - wifi_roaming
    - roaming_daemon

- name: Display WiFi roaming daemon status
  ansible.builtin.debug:
    msg: "WiFi roaming daemon is {{ roaming_daemon_status.status.ActiveState }}"
  when:
    - network.wifi.roaming.enabled | default(false)
    - roaming_daemon_status is defined
  tags:
    - wifi_roaming
    - roaming_daemon
