---
# roles/wifi_access_point/tasks/main.yml
# Final clean single-document tasks for AP bring-up.

- name: Assert required wifi variables are defined
  ansible.builtin.assert:
    that:
      - network.wifi.interface is defined
      - network.wifi.ssid is defined
      - network.wifi.password is defined
      - network.wifi.ip is defined
      - network.wifi.dhcp_range_start is defined
      - network.wifi.dhcp_range_end is defined
    msg: "Required wifi_access_point variables missing. See roles/wifi_access_point/README.md"

- name: Fail if attempting to configure the control interface (avoid disconnecting admin)
  ansible.builtin.fail:
    msg: "Refusing to modify {{ network.wifi.interface }} because it matches the control interface {{ ansible_default_ipv4.interface }}. Set network.wifi.interface to a secondary adapter (e.g. wlan1) or set force_apply=true to override."
  when:
    - (network.wifi.interface == ansible_default_ipv4.interface) and (force_apply | default(false) | bool) == false

- name: Install packages required for AP
  ansible.builtin.apt:
    name: "{{ wifi_ap_packages | default(['hostapd','dnsmasq','rfkill','iw','dhcpcd5']) }}"
    state: present
    update_cache: yes

- name: Check which conflicting services exist
  ansible.builtin.systemd:
    name: "{{ item }}"
  loop:
    - systemd-resolved
    - NetworkManager
    - wpa_supplicant
  register: service_check
  failed_when: false
  changed_when: false

- name: Stop and disable conflicting services (best-effort)
  ansible.builtin.systemd:
    name: "{{ item.item }}"
    state: stopped
    enabled: no
    masked: yes
  loop: "{{ service_check.results }}"
  when: item.status is defined and item.status.LoadState == "loaded"
  ignore_errors: yes

- name: Deploy dhcpcd configuration for the AP
  ansible.builtin.template:
    src: dhcpcd.conf.j2
    dest: /etc/dhcpcd.conf
    mode: '0644'
    backup: yes

- name: Restart dhcpcd
  ansible.builtin.service:
    name: dhcpcd
    state: restarted
    enabled: yes

- name: Wait for AP IP to be present on the host
  ansible.builtin.wait_for:
    host: "{{ network.wifi.ip }}"
    timeout: 20

- name: Unblock all WiFi devices via rfkill (Critical for AP startup)
  ansible.builtin.command:
    cmd: rfkill unblock wifi
  changed_when: true
  failed_when: false

- name: Bring up WiFi AP interface unconditionally
  ansible.builtin.command:
    cmd: ip link set {{ network.wifi.interface }} up
  changed_when: true
  failed_when: false

- name: Deploy hostapd configuration
  ansible.builtin.template:
    src: hostapd.conf.j2
    dest: /etc/hostapd/hostapd.conf
    mode: '0644'

- name: Ensure hostapd points at the service config
  ansible.builtin.lineinfile:
    path: /etc/default/hostapd
    regexp: '^#?DAEMON_CONF='
    line: 'DAEMON_CONF="/etc/hostapd/hostapd.conf"'

- name: Unmask hostapd service (required on fresh Raspberry Pi OS)
  ansible.builtin.systemd:
    name: hostapd
    masked: no

- name: Start hostapd
  block:
    - name: Try to reconfigure hostapd (if already running)
      ansible.builtin.command:
        cmd: hostapd_cli -i {{ network.wifi.interface }} reconfigure
      register: hostapd_reconf
      changed_when: hostapd_reconf.rc == 0
      failed_when: false

    - name: Start hostapd if it was not running or reconfigure failed
      ansible.builtin.service:
        name: hostapd
        state: started
        enabled: yes
      when: hostapd_reconf is not defined or hostapd_reconf.rc != 0

  rescue:
    - name: Ensure hostapd service is started (rescue)
      ansible.builtin.service:
        name: hostapd
        state: started
        enabled: yes

- name: Pause briefly to let hostapd initialize
  ansible.builtin.pause:
    seconds: 3

- name: Backup and disable main dnsmasq.conf to prevent conflicts
  ansible.builtin.copy:
    content: |
      # Main dnsmasq.conf disabled by Ansible wifi_access_point role
      # All configuration is in /etc/dnsmasq.d/01-wifi-ap.conf
      # This prevents conflicts with the WiFi AP DHCP/DNS configuration

      # Read configuration from /etc/dnsmasq.d/ directory
      conf-dir=/etc/dnsmasq.d/,.dpkg-dist,.dpkg-old,.dpkg-new
    dest: /etc/dnsmasq.conf
    backup: yes
    mode: '0644'

- name: Ensure dnsmasq directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /var/run/dnsmasq
    - /var/lib/misc
    - /etc/dnsmasq.d

- name: Ensure dnsmasq leases file exists
  ansible.builtin.file:
    path: /var/lib/misc/dnsmasq.leases
    state: touch
    mode: '0644'

- name: Deploy dnsmasq config snippet for AP
  ansible.builtin.template:
    src: dnsmasq.conf.j2
    dest: /etc/dnsmasq.d/01-wifi-ap.conf
    mode: '0644'

- name: Create dnsmasq systemd override directory
  ansible.builtin.file:
    path: /etc/systemd/system/dnsmasq.service.d
    state: directory
    mode: '0755'

- name: Deploy dnsmasq systemd override (fix race condition)
  ansible.builtin.template:
    src: dnsmasq-override.conf.j2
    dest: /etc/systemd/system/dnsmasq.service.d/override.conf
    mode: '0644'

- name: Deploy Frey NAT Manager script
  ansible.builtin.template:
    src: frey-nat-manager.sh.j2
    dest: /usr/local/bin/frey-nat-manager.sh
    mode: '0755'

- name: Deploy Frey NAT Manager service
  ansible.builtin.template:
    src: frey-nat-manager.service.j2
    dest: /etc/systemd/system/frey-nat-manager.service
    mode: '0644'

- name: Reload systemd daemon
  ansible.builtin.systemd:
    daemon_reload: yes

- name: Unmask dnsmasq service (required on fresh Raspberry Pi OS)
  ansible.builtin.systemd:
    name: dnsmasq
    masked: no

- name: Test dnsmasq configuration
  ansible.builtin.command: dnsmasq --test
  register: dnsmasq_test
  changed_when: false
  failed_when: dnsmasq_test.rc != 0

- name: Force restart dnsmasq to apply new configuration
  ansible.builtin.service:
    name: dnsmasq
    state: restarted
    enabled: yes
  when: dnsmasq_test.rc == 0

- name: Enable and start Frey NAT Manager service
  ansible.builtin.service:
    name: frey-nat-manager
    state: started
    enabled: yes

- name: Wait for dnsmasq to bind on port 53 (DNS)
  ansible.builtin.wait_for:
    host: "{{ network.wifi.ip }}"
    port: 53
    timeout: 30

- name: Verify dnsmasq is listening on DHCP port 67
  ansible.builtin.shell: ss -ulnp | grep ':67' || echo "DHCP_NOT_LISTENING"
  register: dhcp_check
  changed_when: false
  failed_when: "'DHCP_NOT_LISTENING' in dhcp_check.stdout"

- name: Display dnsmasq listening ports
  ansible.builtin.shell: ss -ulnp | grep dnsmasq
  register: dnsmasq_ports
  changed_when: false

- name: Show dnsmasq listening status
  ansible.builtin.debug:
    msg: |
      dnsmasq is listening on:
      {{ dnsmasq_ports.stdout_lines | join('\n') }}

- name: Read DHCP leases (best-effort)
  ansible.builtin.command: cat /var/lib/misc/dnsmasq.leases
  register: dhcp_leases
  changed_when: false
  failed_when: false

- name: Display concise AP status
  ansible.builtin.debug:
    msg: |
      WiFi AP Summary:
      Interface: {{ network.wifi.interface }} ({{ network.wifi.ip }})
      SSID: {{ network.wifi.ssid }}
      Hostapd: {{ 'running' if (ansible_facts.services is defined and ansible_facts.services['hostapd.service'] is defined and ansible_facts.services['hostapd.service'].state == 'running') else 'unknown' }}
      dnsmasq: {{ 'running' if (ansible_facts.services is defined and ansible_facts.services['dnsmasq.service'] is defined and ansible_facts.services['dnsmasq.service'].state == 'running') else 'unknown' }}
      DHCP leases entries: {{ dhcp_leases.stdout_lines | length }}
