---
# Enhanced version of roles/media_stack/tasks/main.yml

- name: Verify required variables are defined
  ansible.builtin.assert:
    that:
      - media_stack is defined
      - storage.base_dir is defined
      - user.name is defined
    msg: "Required media_stack variables are not properly defined"

- name: Create media stack directory
  ansible.builtin.file:
    path: "{{ storage.stacks_dir }}/media"
    state: directory
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: '0755'

- name: Pre-pull critical images to avoid timeouts
  community.docker.docker_image:
    name: "{{ item }}"
    source: pull
    state: present
    timeout: 300
  loop:
    - "linuxserver/jellyfin:latest"
    - "linuxserver/sonarr:latest"
    - "linuxserver/radarr:latest"
    - "linuxserver/prowlarr:latest"
  register: image_pull_results
  retries: 2
  delay: 10
  failed_when: false

- name: Report failed image pulls
  ansible.builtin.debug:
    msg: "Warning: Failed to pull {{ item.item }}. Will retry during compose."
  loop: "{{ image_pull_results.results }}"
  when: 
    - item is failed
    - image_pull_results.results is defined
  loop_control:
    label: "{{ item.item }}"

- name: Deploy media stack compose file
  ansible.builtin.template:
    src: docker-compose-media.yml.j2
    dest: "{{ storage.stacks_dir }}/media/docker-compose.yml"
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: '0644'
    backup: yes
  register: compose_template_result

- name: Validate Docker Compose file syntax
  ansible.builtin.command:
    cmd: docker compose -f "{{ storage.stacks_dir }}/media/docker-compose.yml" config --quiet
  register: compose_validation
  failed_when: compose_validation.rc != 0
  changed_when: false

- name: Start media stack with graceful error handling
  block:
    - name: Start media stack containers using compose
      community.docker.docker_compose_v2:
        project_src: "{{ storage.stacks_dir }}/media"
        state: present
        remove_orphans: true
        timeout: 300
      register: compose_result
      retries: 2
      delay: 30

  rescue:
    - name: Handle compose failure - gather logs
      ansible.builtin.command:
        cmd: docker compose -f "{{ storage.stacks_dir }}/media/docker-compose.yml" logs --tail=50
      register: compose_logs
      failed_when: false

    - name: Display compose error details
      ansible.builtin.debug:
        msg: |
          Media stack deployment failed. Recent logs:
          {{ compose_logs.stdout }}
      when: compose_logs.stdout is defined

    - name: Fail with helpful message
      ansible.builtin.fail:
        msg: "Media stack deployment failed. Check the logs above and ensure all required directories exist."

- name: Wait for services to be ready
  ansible.builtin.uri:
    url: "http://localhost:{{ item.port }}"
    method: GET
    status_code: [200, 302, 401, 403]
    timeout: 10
  loop:
    - { service: "jellyfin", port: "{{ media_stack.services.jellyfin.port }}" }
    - { service: "sonarr", port: "{{ media_stack.services.sonarr.port }}" }
    - { service: "radarr", port: "{{ media_stack.services.radarr.port }}" }
    - { service: "prowlarr", port: "{{ media_stack.services.prowlarr.port }}" }
  register: service_health_check
  retries: 6
  delay: 10
  failed_when: false

- name: Report service health status
  ansible.builtin.debug:
    msg: |
      Service Health Status:
      {% for result in service_health_check.results %}
      - {{ result.item.service }}: {{ 'HEALTHY' if result is succeeded else 'NOT READY' }}
      {% endfor %}
  when: service_health_check.results is defined

# Add these tasks to roles/media_stack/tasks/main.yml

- name: Wait for services to be fully ready
  ansible.builtin.uri:
    url: "http://localhost:{{ media_stack.services[item].port }}"
    method: GET
    status_code: [200, 302, 401, 403]
    timeout: 10
  loop:
    - "sonarr"
    - "radarr" 
    - "prowlarr"
    - "qbittorrent"
    - "lidarr"
  register: service_readiness
  retries: 10
  delay: 30
  until: service_readiness is succeeded

# - name: Configure Prowlarr indexers and apps
#   block:
#     - name: Get Prowlarr API key
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.prowlarr.port }}/api/v1/config/host"
#         method: GET
#         headers:
#           X-Api-Key: "{{ media_stack.services.prowlarr.api_key }}"
#       register: prowlarr_config
#       retries: 5
#       delay: 10

#     - name: Add Sonarr to Prowlarr applications
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.prowlarr.port }}/api/v1/applications"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.prowlarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           name: "Sonarr"
#           implementation: "Sonarr"
#           configContract: "SonarrSettings"
#           fields:
#             - name: "baseUrl"
#               value: "{{ media_stack.internal_urls.sonarr }}"
#             - name: "apiKey"
#               value: "{{ media_stack.services.sonarr.api_key }}"
#             - name: "syncLevel"
#               value: "addOnly"
#         status_code: [200, 201]
#       register: prowlarr_sonarr_app
#       failed_when: false

#     - name: Add Radarr to Prowlarr applications  
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.prowlarr.port }}/api/v1/applications"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.prowlarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           name: "Radarr"
#           implementation: "Radarr"
#           configContract: "RadarrSettings" 
#           fields:
#             - name: "baseUrl"
#               value: "{{ media_stack.internal_urls.radarr }}"
#             - name: "apiKey"
#               value: "{{ media_stack.services.radarr.api_key }}"
#             - name: "syncLevel"
#               value: "addOnly"
#         status_code: [200, 201]
#       register: prowlarr_radarr_app
#       failed_when: false

#     - name: Add Lidarr to Prowlarr applications
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.prowlarr.port }}/api/v1/applications"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.prowlarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           name: "Lidarr"
#           implementation: "Lidarr"
#           configContract: "LidarrSettings"
#           fields:
#             - name: "baseUrl" 
#               value: "{{ media_stack.internal_urls.lidarr }}"
#             - name: "apiKey"
#               value: "{{ media_stack.services.lidarr.api_key }}"
#             - name: "syncLevel"
#               value: "addOnly"
#         status_code: [200, 201]
#       register: prowlarr_lidarr_app
#       failed_when: false

#   when: media_stack.services.prowlarr.api_key is defined

# - name: Configure qBittorrent download client in *arr apps
#   block:
#     - name: Add qBittorrent to Sonarr
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.sonarr.port }}/api/v3/downloadclient"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.sonarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           name: "qBittorrent"
#           implementation: "QBittorrent"
#           configContract: "QBittorrentSettings"
#           protocol: "torrent"
#           enable: true
#           fields:
#             - name: "host"
#               value: "{{ media_stack.services.qbittorrent.internal_ip }}"
#             - name: "port"
#               value: "{{ media_stack.services.qbittorrent.port }}"
#             - name: "category"
#               value: "sonarr"
#             - name: "username"
#               value: "admin"
#             - name: "password"
#               value: "{{ vault.media.qbittorrent.default_password if vault is defined and vault.media is defined and vault.media.qbittorrent is defined else 'admin' }}"
#         status_code: [200, 201]
#       register: sonarr_qbt_client
#       failed_when: false

#     - name: Add qBittorrent to Radarr
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.radarr.port }}/api/v3/downloadclient"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.radarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           name: "qBittorrent"
#           implementation: "QBittorrent"
#           configContract: "QBittorrentSettings"
#           protocol: "torrent"
#           enable: true
#           fields:
#             - name: "host"
#               value: "{{ media_stack.services.qbittorrent.internal_ip }}"
#             - name: "port"
#               value: "{{ media_stack.services.qbittorrent.port }}"
#             - name: "category"
#               value: "radarr"
#             - name: "username"
#               value: "admin"  
#             - name: "password"
#               value: "{{ vault.media.qbittorrent.default_password if vault is defined and vault.media is defined and vault.media.qbittorrent is defined else 'admin' }}"
#         status_code: [200, 201]
#       register: radarr_qbt_client
#       failed_when: false

#     - name: Add qBittorrent to Lidarr
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.lidarr.port }}/api/v1/downloadclient"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.lidarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           name: "qBittorrent"
#           implementation: "QBittorrent"
#           configContract: "QBittorrentSettings"
#           protocol: "torrent"
#           enable: true
#           fields:
#             - name: "host"
#               value: "{{ media_stack.services.qbittorrent.internal_ip }}"
#             - name: "port"
#               value: "{{ media_stack.services.qbittorrent.port }}"
#             - name: "category"
#               value: "lidarr"
#             - name: "username"
#               value: "admin"
#             - name: "password"
#               value: "{{ vault.media.qbittorrent.default_password if vault is defined and vault.media is defined and vault.media.qbittorrent is defined else 'admin' }}"
#         status_code: [200, 201]
#       register: lidarr_qbt_client
#       failed_when: false

# - name: Configure media paths in *arr applications
#   block:
#     - name: Configure Sonarr root folder
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.sonarr.port }}/api/v3/rootfolder"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.sonarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           path: "/tv"
#           name: "TV Shows"
#         status_code: [200, 201, 400]  # 400 if already exists
#       register: sonarr_root_folder
#       failed_when: false

#     - name: Configure Radarr root folder
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.radarr.port }}/api/v3/rootfolder"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.radarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           path: "/movies"
#           name: "Movies"
#         status_code: [200, 201, 400]  # 400 if already exists
#       register: radarr_root_folder
#       failed_when: false

#     - name: Configure Lidarr root folder
#       ansible.builtin.uri:
#         url: "http://localhost:{{ media_stack.services.lidarr.port }}/api/v1/rootfolder"
#         method: POST
#         headers:
#           X-Api-Key: "{{ media_stack.services.lidarr.api_key }}"
#           Content-Type: "application/json"
#         body_format: json
#         body:
#           path: "/music"
#           name: "Music"
#         status_code: [200, 201, 400]  # 400 if already exists
#       register: lidarr_root_folder
#       failed_when: false

# - name: Report configuration status
#   ansible.builtin.debug:
#     msg: |
#       Media Stack Configuration Summary:
#       - Prowlarr â†’ Sonarr: {{ 'SUCCESS' if prowlarr_sonarr_app is succeeded else 'SKIPPED/FAILED' }}
#       - Prowlarr â†’ Radarr: {{ 'SUCCESS' if prowlarr_radarr_app is succeeded else 'SKIPPED/FAILED' }}  
#       - Prowlarr â†’ Lidarr: {{ 'SUCCESS' if prowlarr_lidarr_app is succeeded else 'SKIPPED/FAILED' }}
#       - qBittorrent â†’ Sonarr: {{ 'SUCCESS' if sonarr_qbt_client is succeeded else 'SKIPPED/FAILED' }}
#       - qBittorrent â†’ Radarr: {{ 'SUCCESS' if radarr_qbt_client is succeeded else 'SKIPPED/FAILED' }}
#       - qBittorrent â†’ Lidarr: {{ 'SUCCESS' if lidarr_qbt_client is succeeded else 'SKIPPED/FAILED' }}

#       Next Steps:
#       1. Access Prowlarr to add indexers: http://prowlarr.{{ media_stack.domain_name }}
#       2. Services should automatically sync indexers from Prowlarr
#       3. Download clients are pre-configured with internal IPs

# Add these tasks to your existing media_stack role

- name: Create download directory structure
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: '0775'
  loop:
    - "{{ media_stack.downloads_dir }}/complete"
    - "{{ media_stack.downloads_dir }}/incomplete"
    - "{{ media_stack.downloads_dir }}/complete/sonarr"
    - "{{ media_stack.downloads_dir }}/complete/radarr"
    - "{{ media_stack.downloads_dir }}/complete/lidarr"
    - "{{ media_stack.downloads_dir }}/complete/manual"

- name: Template qBittorrent configuration
  ansible.builtin.template:
    src: qbittorrent.conf.j2
    dest: "{{ media_stack.appdata_dir }}/qbittorrent/qBittorrent/qBittorrent.conf"
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: '0644'
  notify: restart qbittorrent

# - name: Create API key files for *arr applications
#   ansible.builtin.copy:
#     content: "{{ item.api_key }}"
#     dest: "{{ media_stack.appdata_dir }}/{{ item.name }}/config.xml.api_key"
#     owner: "{{ user.name }}"
#     group: "{{ user.name }}"
#     mode: '0600'
#   loop:
#     - { name: "sonarr", api_key: "{{ media_stack.services.sonarr.api_key }}" }
#     - { name: "radarr", api_key: "{{ media_stack.services.radarr.api_key }}" }
#     - { name: "prowlarr", api_key: "{{ media_stack.services.prowlarr.api_key }}" }
#     - { name: "lidarr", api_key: "{{ media_stack.services.lidarr.api_key }}" }
#   when: item.api_key is defined

# - name: Generate service connection info file
#   ansible.builtin.template:
#     src: service_connections.yml.j2  
#     dest: "{{ storage.base_dir }}/service_connections.yml"
#     owner: "{{ user.name }}"
#     group: "{{ user.name }}"
#     mode: '0644'

# - name: Wait for all containers to be healthy
#   community.docker.docker_container_info:
#     name: "{{ item }}"
#   register: container_info
#   until: container_info.container.State.Status == "running"
#   retries: 10
#   delay: 15
#   loop:
#     - "{{ media_stack.services.sonarr.container_name }}"
#     - "{{ media_stack.services.radarr.container_name }}"
#     - "{{ media_stack.services.prowlarr.container_name }}"
#     - "{{ media_stack.services.qbittorrent.container_name }}"
#     - "{{ media_stack.services.lidarr.container_name }}"

# - name: Test internal network connectivity
#   ansible.builtin.command:
#     cmd: "docker exec {{ media_stack.services.sonarr.container_name }} ping -c 1 {{ media_stack.services.prowlarr.internal_ip }}"
#   register: network_test
#   failed_when: network_test.rc != 0
#   changed_when: false

# - name: Display network configuration summary
#   ansible.builtin.debug:
#     msg: |
#       ðŸ“¡ Media Stack Internal Network Configuration:
      
#       Network: {{ media_stack.network.name }} ({{ media_stack.network.subnet }})
      
#       Service Internal URLs:
#       {% for service_name, url in media_stack.internal_urls.items() %}
#       - {{ service_name | title }}: {{ url }}
#       {% endfor %}
      
#       âœ… Network connectivity test: {{ 'PASSED' if network_test.rc == 0 else 'FAILED' }}
      
#       ðŸ”§ Next: Configure indexers in Prowlarr, they'll auto-sync to other *arr apps!